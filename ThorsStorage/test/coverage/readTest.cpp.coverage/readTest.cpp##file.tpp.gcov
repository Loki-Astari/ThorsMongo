        -:    0:Source:../file.tpp
        -:    0:Graph:coverage/readTest.gcno
        -:    0:Data:coverage/readTest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#ifndef THORSANVIL_FILESYSTEM_COLUMNFORMAT_FILE_TPP
        -:    2:#define THORSANVIL_FILESYSTEM_COLUMNFORMAT_FILE_TPP
        -:    3:
        -:    4:#include "file.h"
        -:    5:#include <iostream>
        -:    6:#include <string_view>
        -:    7:
        -:    8:namespace ThorsAnvil
        -:    9:{
        -:   10:    namespace FileSystem
        -:   11:    {
        -:   12:        namespace ColumnFormat
        -:   13:        {
        -:   14:
        -:   15:    namespace Impl
        -:   16:    {
        -:   17:        /*
        -:   18:         * FileAccessObjectType:        Given a type T knows how to access the underlying File for the type.
        -:   19:         *                              Note the file type will be defined in file.h by Impl::FileType
        -:   20:         *
        -:   21:         *                              Note we use the template type F to represent the type as FileType is specialized
        -:   22:         *                              by S (the stream) which could be (std::ifstream, std::ofstream, std::stream).
        -:   23:         *
        -:   24:         * But there are three basic versions:
        -:   25:         *                      Given a type T The type of file we will use to store it.
        -:   26:         *                      A: If T is a POD type this is type S (which will be one std::ifstream, std::ofstream, std::fstream)
        -:   27:         *                              For most operations we simply pass on the call,
        -:   28:         *                      B: If T is a std::string this type is a struct with S being used to hold data and std::fstream used to hold an index into the strings.
        -:   29:         *                              For most operations we simply pass on the call.
        -:   30:         *                              For writes we add an additional write for the index to the start of the next line.
        -:   31:         *                              seekp() and seekg() read the index files before seeking in the data file.
        -:   32:         *                      C: If T is an object mapped by ThorsAnvil_MakeTrait (see ThorsSerializer) then File<S, T>.
        -:   33:         *                              For most operations we simply pass on the call,
        -:   34:         */
        -:   35:
        -:   36:        // Default versions handles case C: the File type is File<S, T>
        -:   37:        template<typename F, typename T, ThorsAnvil::Serialize::TraitType type>
        -:   38:        struct FileAccessObjectType
        -:   39:        {
        -:   40:            F&  file;
    #####:   41:            FileAccessObjectType(F& file)
    #####:   42:                : file(file)
    #####:   43:            {}
        -:   44:
    #####:   45:            OpenState<T> openTry(bool& ok, std::string&& path, openmode mode)
        -:   46:            {
    #####:   47:                return file.doOpenTry(ok, std::move(path), mode);
        -:   48:            }
    #####:   49:            void openFinalize(bool ok, std::string&& path, openmode mode, OpenState<T> const& state)
        -:   50:            {
    #####:   51:                file.doOpenFin(ok, std::move(path), mode, state);
    #####:   52:            }
        -:   53:            void close()                                {file.close();}
      150:   54:            void read(T& obj)                           {file.read(obj);}
    #####:   55:            void write(T const& obj) const              {file.write(obj);}
    #####:   56:            void setstate(iostate extraState)           {file.setstate(extraState);}
    #####:   57:            void clear(iostate newState)                {file.clear(newState);}
    #####:   58:            iostate rdstate() const                     {return file.rdstate();}
        -:   59:            void seekg(streampos pos)                   {file.seekg(pos);}
        -:   60:            void seekp(streampos pos)                   {file.seekp(pos);}
        -:   61:        };
        -:   62:
        -:   63:        // This specialization for Value types handles all POD types and F is a standrard library strean
        -:   64:        template<typename F, typename T>
        -:   65:        struct FileAccessObjectType<F, T, ThorsAnvil::Serialize::TraitType::Value>
        -:   66:        {
        -:   67:            F&  file;
    #####:   68:            FileAccessObjectType(F& file)
    #####:   69:                : file(file)
    #####:   70:            {}
        -:   71:
    #####:   72:            PreOpenState openTry(bool& ok, std::string const& path, openmode mode)
        -:   73:            {
    #####:   74:                ok = ok && FileSystem::isFileOpenable(path, mode);
    #####:   75:                return NoAction;
        -:   76:            }
    #####:   77:            void openFinalize(bool ok, std::string const& path, openmode mode, PreOpenState const&)
        -:   78:            {
    #####:   79:                if (ok)
        -:   80:                {
    #####:   81:                    file.open(path.c_str(), mode);
    #####:   82:                }
    #####:   83:            }
        -:   84:            void close()                                {file.close();}
      150:   85:            void read(T& obj)                           {file.read(reinterpret_cast<char*>(&obj), sizeof(T));}
    #####:   86:            void write(T const& obj) const              {file.write(reinterpret_cast<char const*>(&obj), sizeof(T));}
    #####:   87:            void setstate(iostate extraState)           {file.setstate(extraState);}
    #####:   88:            void clear(iostate newState)                {file.clear(newState);}
    #####:   89:            iostate rdstate() const                     {return file.rdstate();}
        -:   90:            void seekg(streampos pos)                   {file.seekg(pos * sizeof(T));}
        -:   91:            void seekp(streampos pos)                   {file.seekp(pos * sizeof(T));}
        -:   92:        };
        -:   93:
        -:   94:        // This specialization for std::string keeps track of the data and an index into the data.
        -:   95:        template<typename F>
        -:   96:        struct FileAccessObjectType<F, std::string, ThorsAnvil::Serialize::TraitType::Value>
        -:   97:        {
        -:   98:            F&  file;
    #####:   99:            FileAccessObjectType(F& file)
    #####:  100:                : file(file)
    #####:  101:            {}
        -:  102:
    #####:  103:            PreOpenState openTry(bool& ok, std::string const& path, openmode mode)
        -:  104:            {
    #####:  105:                ok = ok && FileSystem::isFileOpenable(path, mode);
    #####:  106:                return NoAction;
        -:  107:            }
    #####:  108:            void openFinalize(bool ok, std::string const& path, openmode mode, PreOpenState const&)
        -:  109:            {
    #####:  110:                if (ok)
        -:  111:                {
    #####:  112:                    file.data.open(path, mode);
        -:  113:                    {
    #####:  114:                        std::ofstream touch(path + ".index", std::ios::app);
    #####:  115:                    }
    #####:  116:                    file.index.open(path + ".index", mode | std::ios_base::in | std::ios_base::out);
    #####:  117:                }
    #####:  118:            }
        -:  119:            void close()
        -:  120:            {
        -:  121:                file.data.close();
        -:  122:                file.index.close();
        -:  123:            }
      150:  124:            void read(std::string& obj)
        -:  125:            {
      150:  126:                std::getline(file.data, obj);
      657:  127:                std::transform(std::begin(obj), std::end(obj), std::begin(obj), [](char x){return x == '\0' ? '\n' : x;});
      150:  128:            }
    #####:  129:            void write(std::string const& obj)
        -:  130:            {
    #####:  131:                std::string::const_iterator start   = std::begin(obj);
    #####:  132:                std::size_t                 used    = 0;
        -:  133:
    #####:  134:                for (std::size_t size = obj.find('\n'); size != std::string::npos; size = obj.find('\n', size + 1))
        -:  135:                {
    #####:  136:                    size = (size == std::string::npos) ? (std::end(obj) - start) : size;
    #####:  137:                    std::size_t len = (size - used);
    #####:  138:                    file.data << std::string_view(&*start, size - used) << '\0';
        -:  139:
    #####:  140:                    start += (len + 1);
    #####:  141:                    used  += (len + 1);
    #####:  142:                }
    #####:  143:                file.data << std::string_view(&*start) << "\n";
    #####:  144:                streampos index = file.data.tellp();
    #####:  145:                file.index.write(reinterpret_cast<char*>(&index), sizeof(streampos));
    #####:  146:            }
    #####:  147:            void setstate(iostate extraState)           {file.data.setstate(extraState);file.index.setstate(extraState);}
    #####:  148:            void clear(iostate newState)                {file.data.clear(newState);file.index.clear(newState);}
    #####:  149:            iostate rdstate() const                     {return file.data.rdstate() | file.index.rdstate();}
        -:  150:            void seekg(streampos pos)
        -:  151:            {
        -:  152:                if (pos == 0)
        -:  153:                {
        -:  154:                    file.index.seekg(0);
        -:  155:                    file.data.seekg(0);
        -:  156:                }
        -:  157:                else
        -:  158:                {
        -:  159:                    file.index.seekg(pos * sizeof(std::size_t) - sizeof(std::size_t));
        -:  160:                    streampos index;
        -:  161:                    file.index.read(reinterpret_cast<char*>(&index), sizeof(streampos));
        -:  162:                    file.data.seekg(index);
        -:  163:                }
        -:  164:            }
        -:  165:            void seekp(streampos pos)
        -:  166:            {
        -:  167:                if (pos == 0)
        -:  168:                {
        -:  169:                    file.index.seekp(0);
        -:  170:                    file.data.seekp(0);
        -:  171:                }
        -:  172:                else
        -:  173:                {
        -:  174:                    file.index.seekg(pos * sizeof(std::size_t) - sizeof(std::size_t));
        -:  175:                    streampos index;
        -:  176:                    file.index.read(reinterpret_cast<char*>(&index), sizeof(streampos));
        -:  177:                    file.index.seekp(pos * sizeof(std::size_t) - sizeof(std::size_t));
        -:  178:                    file.data.seekp(index);
        -:  179:                }
        -:  180:            }
        -:  181:        };
        -:  182:
        -:  183:        template<typename S, typename T, std::size_t I>
        -:  184:        struct FileAccessObjectSelector
        -:  185:        {
        -:  186:            using Traits            = ThorsAnvil::Serialize::Traits<T>;
        -:  187:            using Members           = typename Traits::Members;
        -:  188:            using FileTuple         = TupleFileType<S, T>;
        -:  189:
        -:  190:            using FileIndex         = std::tuple_element_t<I, FileTuple>;
        -:  191:            using PointerTypeIndex  = std::tuple_element_t<I, Members>;
        -:  192:            using DstIndex          = GetPointerMemberType<PointerTypeIndex>;
        -:  193:
        -:  194:            using FileAccessObject  = FileAccessObjectType<FileIndex, DstIndex>;
        -:  195:        };
        -:  196:        // Given an S, T and an index I.
        -:  197:        template<typename S, typename T, std::size_t I>
        -:  198:        using FileAccessObject      = typename FileAccessObjectSelector<S, T, I>::FileAccessObject;
        -:  199:
    #####:  200:    }
        -:  201:
        -:  202:    // ==== FileMembers ====
        -:  203:
        -:  204:    template<typename S, typename T>
    #####:  205:    inline FileMembers<S, T>::FileMembers()
    #####:  206:        : state(failbit)
    #####:  207:    {}
        -:  208:
        -:  209:    // ---- Open ----
        -:  210:
        -:  211:    // void FileBase<S, T>::open for a description of the open processes.
        -:  212:    template<typename S, typename T>
    #####:  213:    inline Impl::OpenState<T> FileMembers<S, T>::doOpenTry(bool& ok, std::string const& path, openmode mode)
        -:  214:    {
    #####:  215:        Impl::OpenState<T>  result;
    #####:  216:        if (!ok)
        -:  217:        {
    #####:  218:            result.base = Impl::NoAction;
    #####:  219:            return result;
        -:  220:        }
        -:  221:
    #####:  222:        FileSystem::DirResult createDir = FileSystem::makeDirectory(path, 0'777);
        -:  223:
    #####:  224:        if (createDir == FileSystem::DirFailedToCreate)
        -:  225:        {
    #####:  226:            ok          = false;
    #####:  227:            result.base = Impl::NoAction;
    #####:  228:            return result;
        -:  229:        }
        -:  230:
    #####:  231:        result.base = createDir == FileSystem::DirAlreadyExists ? Impl::DirExists : Impl::NoDir;
    #####:  232:        result.members = doOpenTryMembers(ok, path, mode, Index{});
    #####:  233:        return result;
    #####:  234:    }
        -:  235:
        -:  236:    template<typename S, typename T>
        -:  237:    template<std::size_t... I>
    #####:  238:    inline Impl::OpenMemberTuple<T> FileMembers<S, T>::doOpenTryMembers(bool& ok, std::string const& path, openmode mode, std::index_sequence<I...>)
        -:  239:    {
    #####:  240:        Impl::OpenMemberTuple<T> result = std::make_tuple([this, &ok, &path, mode]()
        -:  241:        {
    #####:  242:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
        -:  243:
    #####:  244:            auto result = fileAccess.openTry(ok, getMemberFilePath<I>(path), mode);
    #####:  245:            setstateLocalOnly(fileAccess.rdstate());
    #####:  246:            return result;
    #####:  247:        }()...);
        -:  248:
    #####:  249:        return result;
        -:  250:    }
        -:  251:
        -:  252:    template<typename S, typename T>
    #####:  253:    inline void FileMembers<S, T>::doOpenFin(bool ok, std::string const& path, openmode mode, Impl::OpenState<T> const& state)
        -:  254:    {
    #####:  255:        if (state.base == Impl::NoAction)
        -:  256:        {
    #####:  257:            return;
        -:  258:        }
        -:  259:
    #####:  260:        doOpenFinMembers(ok, path,  mode, state.members, Index{});
        -:  261:
    #####:  262:        if (!ok && state.base == Impl::NoDir)
        -:  263:        {
    #####:  264:            FileSystem::removeFileOrDirectory(path);
    #####:  265:            // We should probably log something if we fail to remove the directory.
        -:  266:            // I don't think an exception is appropriate at this point we have already failed
        -:  267:            // to create the file if this is the issue then we don't want to create in appropriate errors and a few
        -:  268:            // extra directories in the file system is not going to hurt
    #####:  269:        }
    #####:  270:    }
        -:  271:
        -:  272:    template<typename S, typename T>
        -:  273:    template<std::size_t... I>
    #####:  274:    inline void FileMembers<S, T>::doOpenFinMembers(bool ok, std::string const& path, openmode mode, Impl::OpenMemberTuple<T> const& state, std::index_sequence<I...>)
        -:  275:    {
    #####:  276:        ([this, ok, &path, mode, &state]()
        -:  277:        {
    #####:  278:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
        -:  279:
    #####:  280:            fileAccess.openFinalize(ok, getMemberFilePath<I>(path), mode, std::get<I>(state));
    #####:  281:            setstateLocalOnly(fileAccess.rdstate());
    #####:  282:        }(), ...);
    #####:  283:    }
        -:  284:
        -:  285:    // ---- Close ----
        -:  286:
        -:  287:    template<typename S, typename T>
        -:  288:    template<std::size_t... I>
        -:  289:    inline void FileMembers<S, T>::doCloseMembers(std::index_sequence<I...>)
        -:  290:    {
        -:  291:        // Using fold expression and lambda.
        -:  292:        ([this]()
        -:  293:        {
        -:  294:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
        -:  295:            fileAccess.close();
        -:  296:            setstateLocalOnly(fileAccess.rdstate());
        -:  297:        }(), ...);
        -:  298:    }
        -:  299:
        -:  300:    // ---- Read/Write ----
        -:  301:
        -:  302:    template<typename S, typename T>
        -:  303:    template<std::size_t... I>
      225:  304:    inline void FileMembers<S, T>::readMembers(T& data, std::index_sequence<I...>)
        -:  305:    {
        -:  306:        // Using fold expression and lambda.
      675:  307:        ([this, &data]()
        -:  308:        {
      450:  309:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
      450:  310:            auto& members       = Traits::getMembers();
      450:  311:            auto& pointer       = std::get<I>(members).second;
        -:  312:
      450:  313:            fileAccess.read(data.*pointer);
      450:  314:            setstateLocalOnly(fileAccess.rdstate());
      450:  315:        }(), ...);
      225:  316:    }
        -:  317:
        -:  318:    template<typename S, typename T>
        -:  319:    template<std::size_t... I>
    #####:  320:    inline void FileMembers<S, T>::writeMembers(T const& data, std::index_sequence<I...>)
        -:  321:    {
        -:  322:        // Using fold expression and lambda.
    #####:  323:        ([this, &data]()
        -:  324:        {
    #####:  325:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
    #####:  326:            auto& members       = Traits::getMembers();
    #####:  327:            auto& pointer       = std::get<I>(members).second;
        -:  328:
    #####:  329:            fileAccess.write(data.*pointer);
    #####:  330:            setstateLocalOnly(fileAccess.rdstate());
    #####:  331:        }(), ...);
    #####:  332:    }
        -:  333:
        -:  334:    // ---- Clear State Bits ----
        -:  335:
        -:  336:    template<typename S, typename T>
        -:  337:    template<std::size_t... I>
    #####:  338:    inline void FileMembers<S, T>::clearMembers(iostate newState, std::index_sequence<I...>)
        -:  339:    {
        -:  340:        // Using fold expression and lambda.
    #####:  341:        ([this, newState]()
        -:  342:        {
    #####:  343:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
    #####:  344:            fileAccess.clear(newState);
    #####:  345:        }(), ...);
    #####:  346:    }
        -:  347:
        -:  348:    // ---- Set State Bits ----
        -:  349:
        -:  350:    template<typename S, typename T>
        -:  351:    template<std::size_t... I>
    #####:  352:    inline void FileMembers<S, T>::setstateMembers(iostate extraState, std::index_sequence<I...>)
        -:  353:    {
    #####:  354:        ([this, extraState]()
        -:  355:        {
    #####:  356:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
    #####:  357:            fileAccess.setstate(extraState);
    #####:  358:        }(), ...);
    #####:  359:    }
        -:  360:
        -:  361:    // ---- seek ----
        -:  362:    template<typename S, typename T>
        -:  363:    template<std::size_t... I>
        -:  364:    inline void FileMembers<S, T>::seekgMembers(streampos pos, std::index_sequence<I...>)
        -:  365:    {
        -:  366:        ([this, pos]()
        -:  367:        {
        -:  368:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
        -:  369:            fileAccess.seekg(pos);
        -:  370:        }(), ...);
        -:  371:    }
        -:  372:
        -:  373:    template<typename S, typename T>
        -:  374:    template<std::size_t... I>
        -:  375:    inline void FileMembers<S, T>::seekpMembers(streampos pos, std::index_sequence<I...>)
        -:  376:    {
        -:  377:        ([this, pos]()
        -:  378:        {
        -:  379:            Impl::FileAccessObject<S, T, I>  fileAccess(std::get<I>(fileTuple));
        -:  380:            fileAccess.seekp(pos);
        -:  381:        }(), ...);
        -:  382:    }
        -:  383:
        -:  384:    // ---- Get Index Element Path Name from base ----
        -:  385:
        -:  386:    template<typename S, typename T>
        -:  387:    template<std::size_t I>
    #####:  388:    inline std::string FileMembers<S, T>::getMemberFilePath(std::string const& path)
        -:  389:    {
    #####:  390:        std::string filePath = path;
    #####:  391:        filePath += "/";
    #####:  392:        filePath += std::get<I>(Traits::getMembers()).first;
        -:  393:
    #####:  394:        return filePath;
    #####:  395:    }
        -:  396:
        -:  397:    // ===== FileBase =========
        -:  398:
        -:  399:    template<typename S, typename T>
    #####:  400:    inline FileBase<S, T>::FileBase(std::string fileName, openmode mode)
    #####:  401:        : fileOpened(false)
    #####:  402:        , baseFileName(std::move(fileName))
    #####:  403:        , getPos(0)
    #####:  404:        , putPos(0)
        -:  405:    {
    #####:  406:        open(mode);
    #####:  407:    }
        -:  408:
        -:  409:    // ---- Open ----
        -:  410:    // Open is complex:
        -:  411:    //  Only the first function here is public.
        -:  412:    //  The second is the main entry point called by the public open and the constructor.
        -:  413:    //  It performs the open in two two stages:
        -:  414:    //      Stage 1:    doOpenTry:
        -:  415:    //                      Create Directory if they don't exist.
        -:  416:    //                      Check if required files can be opened in the required mode in a directory.
        -:  417:    //      Stage 2:    doOpenFin:
        -:  418:    //                      If all files can be created then create all files.
        -:  419:    //                      If we can not create all the files then remove the directories we created in stage 1.
        -:  420:
        -:  421:    template<typename S, typename T>
        -:  422:    inline void FileBase<S, T>::open(std::string fileName, openmode mode)
        -:  423:    {
        -:  424:        if (fileOpened)
        -:  425:        {
        -:  426:            FileMembers<S, T>::setstate(failbit);
        -:  427:            return;
        -:  428:        }
        -:  429:        baseFileName = std::move(fileName);
        -:  430:        open(mode);
        -:  431:    }
        -:  432:
        -:  433:    template<typename S, typename T>
    #####:  434:    inline void FileBase<S, T>::open(openmode mode)
        -:  435:    {
    #####:  436:        if (baseFileName == "")
        -:  437:        {
    #####:  438:            return;
        -:  439:        }
    #####:  440:        fileOpened = true;
    #####:  441:        FileMembers<S, T>::clear();
        -:  442:
    #####:  443:        Impl::OpenState<T> state = FileMembers<S, T>::doOpenTry(fileOpened, baseFileName, mode);
    #####:  444:        FileMembers<S, T>::doOpenFin(fileOpened, baseFileName, mode, state);
        -:  445:
    #####:  446:        if (!fileOpened)
        -:  447:        {
    #####:  448:            FileMembers<S, T>::setstate(failbit);
    #####:  449:        }
        -:  450:        else
        -:  451:        {
    #####:  452:            index.open(baseFileName + "/$index", mode);
    #####:  453:            getPos  = index.tellg();
    #####:  454:            putPos  = index.tellp();
        -:  455:        }
    #####:  456:    }
        -:  457:
        -:  458:    // ---- close ----
        -:  459:
        -:  460:    template<typename S, typename T>
        -:  461:    inline void FileBase<S, T>::close()
        -:  462:    {
        -:  463:        if (!fileOpened)
        -:  464:        {
        -:  465:            return;
        -:  466:        }
        -:  467:        FileMembers<S, T>::close();
        -:  468:        FileBase<S, T>::setstateLocalOnly(failbit);
        -:  469:        fileOpened = false;
        -:  470:    }
        -:  471:
        -:  472:    // ---- read/write ----
        -:  473:
        -:  474:    template<typename S, typename T>
       76:  475:    inline void FileBase<S, T>::read(T& data)
        -:  476:    {
       76:  477:        if (!FileMembers<S, T>::good())
        -:  478:        {
        1:  479:            return;
        -:  480:        }
       75:  481:        FileMembers<S, T>::read(data);
        -:  482:        char mark;
       75:  483:        index.read(&mark, 1);
       75:  484:        ++getPos;
       76:  485:    }
        -:  486:
        -:  487:    template<typename S, typename T>
    #####:  488:    inline void FileBase<S, T>::write(T const& data)
        -:  489:    {
    #####:  490:        if (!FileMembers<S, T>::good())
        -:  491:        {
    #####:  492:            return;
        -:  493:        }
    #####:  494:        FileMembers<S, T>::write(data);
    #####:  495:        char mark = 'A';
    #####:  496:        index.write(&mark, 1);
    #####:  497:        ++putPos;
    #####:  498:    }
        -:  499:
        -:  500:    // ---- tell/seek ----
        -:  501:    template<typename S, typename T>
        -:  502:    inline void FileBase<S, T>::seekg(streampos pos)
        -:  503:    {
        -:  504:        index.seekg(pos);
        -:  505:        FileMembers<S, T>::seekg(pos);
        -:  506:        getPos  = pos;
        -:  507:    }
        -:  508:
        -:  509:    template<typename S, typename T>
        -:  510:    inline void FileBase<S, T>::seekp(streampos pos)
        -:  511:    {
        -:  512:        index.seekp(pos);
        -:  513:        FileMembers<S, T>::seekp(pos);
        -:  514:        putPos = pos;
        -:  515:    }
        -:  516:    template<typename S, typename T>
        -:  517:    inline void FileBase<S, T>::seekg(streamoff off, seekdir dir)
        -:  518:    {
        -:  519:        index.seekg(off, dir);
        -:  520:        streampos pos = index.tellg();
        -:  521:        seekg(pos);
        -:  522:    }
        -:  523:    template<typename S, typename T>
        -:  524:    inline void FileBase<S, T>::seekp(streamoff off, seekdir dir)
        -:  525:    {
        -:  526:        index.seekp(off, dir);
        -:  527:        streampos pos = index.tellp();
        -:  528:        seekp(pos);
        -:  529:    }
        -:  530:
        -:  531:        }
        -:  532:    }
        -:  533:}
        -:  534:
        -:  535:#endif
