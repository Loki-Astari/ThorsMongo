        -:    0:Source:/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/include/c++/v1/tuple
        -:    0:Graph:coverage/indexTest.gcno
        -:    0:Data:coverage/indexTest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:// -*- C++ -*-
        -:    2://===----------------------------------------------------------------------===//
        -:    3://
        -:    4:// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
        -:    5:// See https://llvm.org/LICENSE.txt for license information.
        -:    6:// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
        -:    7://
        -:    8://===----------------------------------------------------------------------===//
        -:    9:
        -:   10:#ifndef _LIBCPP_TUPLE
        -:   11:#define _LIBCPP_TUPLE
        -:   12:
        -:   13:/*
        -:   14:    tuple synopsis
        -:   15:
        -:   16:namespace std
        -:   17:{
        -:   18:
        -:   19:template <class... T>
        -:   20:class tuple {
        -:   21:public:
        -:   22:    explicit(see-below) constexpr tuple();
        -:   23:    explicit(see-below) tuple(const T&...);  // constexpr in C++14
        -:   24:    template <class... U>
        -:   25:        explicit(see-below) tuple(U&&...);  // constexpr in C++14
        -:   26:    tuple(const tuple&) = default;
        -:   27:    tuple(tuple&&) = default;
        -:   28:
        -:   29:    template<class... UTypes>
        -:   30:        constexpr explicit(see-below) tuple(tuple<UTypes...>&);  // C++23
        -:   31:    template <class... U>
        -:   32:        explicit(see-below) tuple(const tuple<U...>&);  // constexpr in C++14
        -:   33:    template <class... U>
        -:   34:        explicit(see-below) tuple(tuple<U...>&&);  // constexpr in C++14
        -:   35:    template<class... UTypes>
        -:   36:        constexpr explicit(see-below) tuple(const tuple<UTypes...>&&); // C++23
        -:   37:
        -:   38:    template<class U1, class U2>
        -:   39:        constexpr explicit(see-below) tuple(pair<U1, U2>&);  // iff sizeof...(Types) == 2 // C++23
        -:   40:    template <class U1, class U2>
        -:   41:        explicit(see-below) tuple(const pair<U1, U2>&); // iff sizeof...(T) == 2 // constexpr in C++14
        -:   42:    template <class U1, class U2>
        -:   43:        explicit(see-below) tuple(pair<U1, U2>&&); // iff sizeof...(T) == 2  // constexpr in C++14
        -:   44:    template<class U1, class U2>
        -:   45:        constexpr explicit(see-below) tuple(const pair<U1, U2>&&);  // iff sizeof...(Types) == 2 // C++23
        -:   46:
        -:   47:    // allocator-extended constructors
        -:   48:    template <class Alloc>
        -:   49:        tuple(allocator_arg_t, const Alloc& a);
        -:   50:    template <class Alloc>
        -:   51:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const T&...);          // constexpr in C++20
        -:   52:    template <class Alloc, class... U>
        -:   53:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, U&&...);               // constexpr in C++20
        -:   54:    template <class Alloc>
        -:   55:        tuple(allocator_arg_t, const Alloc& a, const tuple&);                             // constexpr in C++20
        -:   56:    template <class Alloc>
        -:   57:        tuple(allocator_arg_t, const Alloc& a, tuple&&);                                  // constexpr in C++20
        -:   58:    template<class Alloc, class... UTypes>
        -:   59:        constexpr explicit(see-below)
        -:   60:          tuple(allocator_arg_t, const Alloc& a, tuple<UTypes...>&);                      // C++23
        -:   61:    template <class Alloc, class... U>
        -:   62:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const tuple<U...>&);   // constexpr in C++20
        -:   63:    template <class Alloc, class... U>
        -:   64:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, tuple<U...>&&);        // constexpr in C++20
        -:   65:    template<class Alloc, class... UTypes>
        -:   66:        constexpr explicit(see-below)
        -:   67:          tuple(allocator_arg_t, const Alloc& a, const tuple<UTypes...>&&);               // C++23
        -:   68:    template<class Alloc, class U1, class U2>
        -:   69:        constexpr explicit(see-below)
        -:   70:          tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&);                          // C++23
        -:   71:    template <class Alloc, class U1, class U2>
        -:   72:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&);  // constexpr in C++20
        -:   73:    template <class Alloc, class U1, class U2>
        -:   74:        explicit(see-below) tuple(allocator_arg_t, const Alloc& a, pair<U1, U2>&&);       // constexpr in C++20
        -:   75:    template<class Alloc, class U1, class U2>
        -:   76:        constexpr explicit(see-below)
        -:   77:          tuple(allocator_arg_t, const Alloc& a, const pair<U1, U2>&&);                   // C++23
        -:   78:
        -:   79:    tuple& operator=(const tuple&);                                                       // constexpr in C++20
        -:   80:    constexpr const tuple& operator=(const tuple&) const;                                 // C++23
        -:   81:    tuple& operator=(tuple&&) noexcept(is_nothrow_move_assignable_v<T> && ...);           // constexpr in C++20
        -:   82:    constexpr const tuple& operator=(tuple&&) const;                                      // C++23
        -:   83:    template <class... U>
        -:   84:        tuple& operator=(const tuple<U...>&);                                             // constexpr in C++20
        -:   85:    template<class... UTypes>
        -:   86:        constexpr const tuple& operator=(const tuple<UTypes...>&) const;                  // C++23
        -:   87:    template <class... U>
        -:   88:        tuple& operator=(tuple<U...>&&);                                                  // constexpr in C++20
        -:   89:    template<class... UTypes>
        -:   90:        constexpr const tuple& operator=(tuple<UTypes...>&&) const;                       // C++23
        -:   91:    template <class U1, class U2>
        -:   92:        tuple& operator=(const pair<U1, U2>&); // iff sizeof...(T) == 2                   // constexpr in C++20
        -:   93:    template<class U1, class U2>
        -:   94:        constexpr const tuple& operator=(const pair<U1, U2>&) const;   // iff sizeof...(Types) == 2 // C++23
        -:   95:    template <class U1, class U2>
        -:   96:        tuple& operator=(pair<U1, U2>&&); // iff sizeof...(T) == 2                        // constexpr in C++20
        -:   97:    template<class U1, class U2>
        -:   98:        constexpr const tuple& operator=(pair<U1, U2>&&) const;  // iff sizeof...(Types) == 2 // C++23
        -:   99:
        -:  100:    template<class U, size_t N>
        -:  101:        tuple& operator=(array<U, N> const&) // iff sizeof...(T) == N, EXTENSION
        -:  102:    template<class U, size_t N>
        -:  103:        tuple& operator=(array<U, N>&&) // iff sizeof...(T) == N, EXTENSION
        -:  104:
        -:  105:    void swap(tuple&) noexcept(AND(swap(declval<T&>(), declval<T&>())...));               // constexpr in C++20
        -:  106:    constexpr void swap(const tuple&) const noexcept(see-below);                          // C++23
        -:  107:};
        -:  108:
        -:  109:
        -:  110:template<class... TTypes, class... UTypes, template<class> class TQual, template<class> class UQual> // since C++23
        -:  111:  requires requires { typename tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>; }
        -:  112:struct basic_common_reference<tuple<TTypes...>, tuple<UTypes...>, TQual, UQual> {
        -:  113:  using type = tuple<common_reference_t<TQual<TTypes>, UQual<UTypes>>...>;
        -:  114:};
        -:  115:
        -:  116:template<class... TTypes, class... UTypes>                                // since C++23
        -:  117:  requires requires { typename tuple<common_type_t<TTypes, UTypes>...>; }
        -:  118:struct common_type<tuple<TTypes...>, tuple<UTypes...>> {
        -:  119:  using type = tuple<common_type_t<TTypes, UTypes>...>;
        -:  120:};
        -:  121:
        -:  122:template <class ...T>
        -:  123:tuple(T...) -> tuple<T...>;                                         // since C++17
        -:  124:template <class T1, class T2>
        -:  125:tuple(pair<T1, T2>) -> tuple<T1, T2>;                               // since C++17
        -:  126:template <class Alloc, class ...T>
        -:  127:tuple(allocator_arg_t, Alloc, T...) -> tuple<T...>;                 // since C++17
        -:  128:template <class Alloc, class T1, class T2>
        -:  129:tuple(allocator_arg_t, Alloc, pair<T1, T2>) -> tuple<T1, T2>;       // since C++17
        -:  130:template <class Alloc, class ...T>
        -:  131:tuple(allocator_arg_t, Alloc, tuple<T...>) -> tuple<T...>;          // since C++17
        -:  132:
        -:  133:inline constexpr unspecified ignore;
        -:  134:
        -:  135:template <class... T> tuple<V...>  make_tuple(T&&...); // constexpr in C++14
        -:  136:template <class... T> tuple<ATypes...> forward_as_tuple(T&&...) noexcept; // constexpr in C++14
        -:  137:template <class... T> tuple<T&...> tie(T&...) noexcept; // constexpr in C++14
        -:  138:template <class... Tuples> tuple<CTypes...> tuple_cat(Tuples&&... tpls); // constexpr in C++14
        -:  139:
        -:  140:// [tuple.apply], calling a function with a tuple of arguments:
        -:  141:template <class F, class Tuple>
        -:  142:  constexpr decltype(auto) apply(F&& f, Tuple&& t); // C++17
        -:  143:template <class T, class Tuple>
        -:  144:  constexpr T make_from_tuple(Tuple&& t); // C++17
        -:  145:
        -:  146:// 20.4.1.4, tuple helper classes:
        -:  147:template <class T> struct tuple_size; // undefined
        -:  148:template <class... T> struct tuple_size<tuple<T...>>;
        -:  149:template <class T>
        -:  150: inline constexpr size_t tuple_size_v = tuple_size<T>::value; // C++17
        -:  151:template <size_t I, class T> struct tuple_element; // undefined
        -:  152:template <size_t I, class... T> struct tuple_element<I, tuple<T...>>;
        -:  153:template <size_t I, class T>
        -:  154:  using tuple_element_t = typename tuple_element <I, T>::type; // C++14
        -:  155:
        -:  156:// 20.4.1.5, element access:
        -:  157:template <size_t I, class... T>
        -:  158:    typename tuple_element<I, tuple<T...>>::type&
        -:  159:    get(tuple<T...>&) noexcept; // constexpr in C++14
        -:  160:template <size_t I, class... T>
        -:  161:    const typename tuple_element<I, tuple<T...>>::type&
        -:  162:    get(const tuple<T...>&) noexcept; // constexpr in C++14
        -:  163:template <size_t I, class... T>
        -:  164:    typename tuple_element<I, tuple<T...>>::type&&
        -:  165:    get(tuple<T...>&&) noexcept; // constexpr in C++14
        -:  166:template <size_t I, class... T>
        -:  167:    const typename tuple_element<I, tuple<T...>>::type&&
        -:  168:    get(const tuple<T...>&&) noexcept; // constexpr in C++14
        -:  169:
        -:  170:template <class T1, class... T>
        -:  171:    constexpr T1& get(tuple<T...>&) noexcept;  // C++14
        -:  172:template <class T1, class... T>
        -:  173:    constexpr const T1& get(const tuple<T...>&) noexcept;   // C++14
        -:  174:template <class T1, class... T>
        -:  175:    constexpr T1&& get(tuple<T...>&&) noexcept;   // C++14
        -:  176:template <class T1, class... T>
        -:  177:    constexpr const T1&& get(const tuple<T...>&&) noexcept;   // C++14
        -:  178:
        -:  179:// 20.4.1.6, relational operators:
        -:  180:template<class... T, class... U> bool operator==(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14
        -:  181:template<class... T, class... U> bool operator<(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
        -:  182:template<class... T, class... U> bool operator!=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  183:template<class... T, class... U> bool operator>(const tuple<T...>&, const tuple<U...>&);  // constexpr in C++14, removed in C++20
        -:  184:template<class... T, class... U> bool operator<=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  185:template<class... T, class... U> bool operator>=(const tuple<T...>&, const tuple<U...>&); // constexpr in C++14, removed in C++20
        -:  186:template<class... T, class... U>
        -:  187:  constexpr common_comparison_category_t<synth-three-way-result<T, U>...>
        -:  188:    operator<=>(const tuple<T...>&, const tuple<U...>&);                                  // since C++20
        -:  189:
        -:  190:template <class... Types, class Alloc>
        -:  191:  struct uses_allocator<tuple<Types...>, Alloc>;
        -:  192:
        -:  193:template <class... Types>
        -:  194:  void
        -:  195:  swap(tuple<Types...>& x, tuple<Types...>& y) noexcept(noexcept(x.swap(y)));
        -:  196:
        -:  197:template <class... Types>
        -:  198:  constexpr void swap(const tuple<Types...>& x, const tuple<Types...>& y) noexcept(see-below);   // C++23
        -:  199:
        -:  200:}  // std
        -:  201:
        -:  202:*/
        -:  203:
        -:  204:#include <__assert> // all public C++ headers provide the assertion handler
        -:  205:#include <__compare/common_comparison_category.h>
        -:  206:#include <__compare/synth_three_way.h>
        -:  207:#include <__config>
        -:  208:#include <__functional/invoke.h>
        -:  209:#include <__functional/unwrap_ref.h>
        -:  210:#include <__fwd/array.h>
        -:  211:#include <__memory/allocator_arg_t.h>
        -:  212:#include <__memory/uses_allocator.h>
        -:  213:#include <__type_traits/apply_cv.h>
        -:  214:#include <__type_traits/common_reference.h>
        -:  215:#include <__type_traits/common_type.h>
        -:  216:#include <__type_traits/conditional.h>
        -:  217:#include <__type_traits/conjunction.h>
        -:  218:#include <__type_traits/copy_cvref.h>
        -:  219:#include <__type_traits/disjunction.h>
        -:  220:#include <__type_traits/is_arithmetic.h>
        -:  221:#include <__type_traits/is_assignable.h>
        -:  222:#include <__type_traits/is_constructible.h>
        -:  223:#include <__type_traits/is_convertible.h>
        -:  224:#include <__type_traits/is_copy_assignable.h>
        -:  225:#include <__type_traits/is_copy_constructible.h>
        -:  226:#include <__type_traits/is_default_constructible.h>
        -:  227:#include <__type_traits/is_empty.h>
        -:  228:#include <__type_traits/is_final.h>
        -:  229:#include <__type_traits/is_implicitly_default_constructible.h>
        -:  230:#include <__type_traits/is_move_assignable.h>
        -:  231:#include <__type_traits/is_move_constructible.h>
        -:  232:#include <__type_traits/is_nothrow_assignable.h>
        -:  233:#include <__type_traits/is_nothrow_constructible.h>
        -:  234:#include <__type_traits/is_nothrow_copy_assignable.h>
        -:  235:#include <__type_traits/is_nothrow_copy_constructible.h>
        -:  236:#include <__type_traits/is_nothrow_default_constructible.h>
        -:  237:#include <__type_traits/is_nothrow_move_assignable.h>
        -:  238:#include <__type_traits/is_reference.h>
        -:  239:#include <__type_traits/is_same.h>
        -:  240:#include <__type_traits/is_swappable.h>
        -:  241:#include <__type_traits/lazy.h>
        -:  242:#include <__type_traits/maybe_const.h>
        -:  243:#include <__type_traits/nat.h>
        -:  244:#include <__type_traits/negation.h>
        -:  245:#include <__type_traits/remove_cvref.h>
        -:  246:#include <__type_traits/remove_reference.h>
        -:  247:#include <__utility/forward.h>
        -:  248:#include <__utility/integer_sequence.h>
        -:  249:#include <__utility/move.h>
        -:  250:#include <__utility/pair.h>
        -:  251:#include <__utility/piecewise_construct.h>
        -:  252:#include <__utility/swap.h>
        -:  253:#include <cstddef>
        -:  254:#include <version>
        -:  255:
        -:  256:// standard-mandated includes
        -:  257:
        -:  258:// [tuple.syn]
        -:  259:#include <compare>
        -:  260:
        -:  261:#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
        -:  262:#  pragma GCC system_header
        -:  263:#endif
        -:  264:
        -:  265:_LIBCPP_BEGIN_NAMESPACE_STD
        -:  266:
        -:  267:#ifndef _LIBCPP_CXX03_LANG
        -:  268:
        -:  269:
        -:  270:// __tuple_leaf
        -:  271:
        -:  272:template <size_t _Ip, class _Hp,
        -:  273:          bool=is_empty<_Hp>::value && !__libcpp_is_final<_Hp>::value
        -:  274:         >
        -:  275:class __tuple_leaf;
        -:  276:
        -:  277:template <size_t _Ip, class _Hp, bool _Ep>
        -:  278:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  279:void swap(__tuple_leaf<_Ip, _Hp, _Ep>& __x, __tuple_leaf<_Ip, _Hp, _Ep>& __y)
        -:  280:    _NOEXCEPT_(__is_nothrow_swappable<_Hp>::value)
        -:  281:{
        -:  282:    swap(__x.get(), __y.get());
        -:  283:}
        -:  284:
        -:  285:template <size_t _Ip, class _Hp, bool _Ep>
        -:  286:_LIBCPP_HIDE_FROM_ABI _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  287:void swap(const __tuple_leaf<_Ip, _Hp, _Ep>& __x, const __tuple_leaf<_Ip, _Hp, _Ep>& __y)
        -:  288:     _NOEXCEPT_(__is_nothrow_swappable<const _Hp>::value) {
        -:  289:  swap(__x.get(), __y.get());
        -:  290:}
        -:  291:
        -:  292:template <size_t _Ip, class _Hp, bool>
        -:  293:class __tuple_leaf
        -:  294:{
        -:  295:    _Hp __value_;
        -:  296:
        -:  297:    template <class _Tp>
        -:  298:    static constexpr bool __can_bind_reference() {
        -:  299:#if __has_keyword(__reference_binds_to_temporary)
        -:  300:      return !__reference_binds_to_temporary(_Hp, _Tp);
        -:  301:#else
        -:  302:      return true;
        -:  303:#endif
        -:  304:    }
        -:  305:
        -:  306:    _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  307:    __tuple_leaf& operator=(const __tuple_leaf&);
        -:  308:public:
    #####:  309:    _LIBCPP_INLINE_VISIBILITY constexpr __tuple_leaf()
    #####:  310:             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) : __value_()
        -:  311:       {static_assert(!is_reference<_Hp>::value,
    #####:  312:              "Attempted to default construct a reference element in a tuple");}
        -:  313:
        -:  314:    template <class _Alloc>
        -:  315:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  316:        __tuple_leaf(integral_constant<int, 0>, const _Alloc&)
        -:  317:            : __value_()
        -:  318:        {static_assert(!is_reference<_Hp>::value,
        -:  319:              "Attempted to default construct a reference element in a tuple");}
        -:  320:
        -:  321:    template <class _Alloc>
        -:  322:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  323:        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        -:  324:            : __value_(allocator_arg_t(), __a)
        -:  325:        {static_assert(!is_reference<_Hp>::value,
        -:  326:              "Attempted to default construct a reference element in a tuple");}
        -:  327:
        -:  328:    template <class _Alloc>
        -:  329:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  330:        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
        -:  331:            : __value_(__a)
        -:  332:        {static_assert(!is_reference<_Hp>::value,
        -:  333:              "Attempted to default construct a reference element in a tuple");}
        -:  334:
        -:  335:    template <class _Tp,
        -:  336:              class = __enable_if_t<
        -:  337:                  _And<
        -:  338:                      _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
        -:  339:                      is_constructible<_Hp, _Tp>
        -:  340:                    >::value
        -:  341:                >
        -:  342:            >
        -:  343:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
    #####:  344:        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
    #####:  345:            : __value_(_VSTD::forward<_Tp>(__t))
        -:  346:        {static_assert(__can_bind_reference<_Tp&&>(),
    #####:  347:       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}
        -:  348:
        -:  349:    template <class _Tp, class _Alloc>
        -:  350:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  351:        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
        -:  352:            : __value_(_VSTD::forward<_Tp>(__t))
        -:  353:        {static_assert(__can_bind_reference<_Tp&&>(),
        -:  354:       "Attempted construction of reference element binds to a temporary whose lifetime has ended");}
        -:  355:
        -:  356:    template <class _Tp, class _Alloc>
        -:  357:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  358:        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
        -:  359:            : __value_(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t))
        -:  360:        {static_assert(!is_reference<_Hp>::value,
        -:  361:            "Attempted to uses-allocator construct a reference element in a tuple");}
        -:  362:
        -:  363:    template <class _Tp, class _Alloc>
        -:  364:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  365:        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
        -:  366:            : __value_(_VSTD::forward<_Tp>(__t), __a)
        -:  367:        {static_assert(!is_reference<_Hp>::value,
        -:  368:           "Attempted to uses-allocator construct a reference element in a tuple");}
        -:  369:
        -:  370:    __tuple_leaf(const __tuple_leaf& __t) = default;
        -:  371:    __tuple_leaf(__tuple_leaf&& __t) = default;
        -:  372:
        -:  373:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  374:    int swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)
        -:  375:    {
        -:  376:        _VSTD::swap(*this, __t);
        -:  377:        return 0;
        -:  378:    }
        -:  379:
        -:  380:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  381:    int swap(const __tuple_leaf& __t) const _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
        -:  382:        _VSTD::swap(*this, __t);
        -:  383:        return 0;
        -:  384:    }
        -:  385:
    #####:  386:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14       _Hp& get()       _NOEXCEPT {return __value_;}
    #####:  387:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {return __value_;}
        -:  388:};
        -:  389:
        -:  390:template <size_t _Ip, class _Hp>
        -:  391:class __tuple_leaf<_Ip, _Hp, true>
        -:  392:    : private _Hp
        -:  393:{
        -:  394:    _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  395:    __tuple_leaf& operator=(const __tuple_leaf&);
        -:  396:public:
        -:  397:    _LIBCPP_INLINE_VISIBILITY constexpr __tuple_leaf()
        -:  398:             _NOEXCEPT_(is_nothrow_default_constructible<_Hp>::value) {}
        -:  399:
        -:  400:    template <class _Alloc>
        -:  401:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  402:        __tuple_leaf(integral_constant<int, 0>, const _Alloc&) {}
        -:  403:
        -:  404:    template <class _Alloc>
        -:  405:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  406:        __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a)
        -:  407:            : _Hp(allocator_arg_t(), __a) {}
        -:  408:
        -:  409:    template <class _Alloc>
        -:  410:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  411:        __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a)
        -:  412:            : _Hp(__a) {}
        -:  413:
        -:  414:    template <class _Tp,
        -:  415:              class = __enable_if_t<
        -:  416:                  _And<
        -:  417:                    _IsNotSame<__remove_cvref_t<_Tp>, __tuple_leaf>,
        -:  418:                    is_constructible<_Hp, _Tp>
        -:  419:                  >::value
        -:  420:                >
        -:  421:            >
        -:  422:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  423:        explicit __tuple_leaf(_Tp&& __t) _NOEXCEPT_((is_nothrow_constructible<_Hp, _Tp>::value))
        -:  424:            : _Hp(_VSTD::forward<_Tp>(__t)) {}
        -:  425:
        -:  426:    template <class _Tp, class _Alloc>
        -:  427:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  428:        explicit __tuple_leaf(integral_constant<int, 0>, const _Alloc&, _Tp&& __t)
        -:  429:            : _Hp(_VSTD::forward<_Tp>(__t)) {}
        -:  430:
        -:  431:    template <class _Tp, class _Alloc>
        -:  432:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  433:        explicit __tuple_leaf(integral_constant<int, 1>, const _Alloc& __a, _Tp&& __t)
        -:  434:            : _Hp(allocator_arg_t(), __a, _VSTD::forward<_Tp>(__t)) {}
        -:  435:
        -:  436:    template <class _Tp, class _Alloc>
        -:  437:        _LIBCPP_INLINE_VISIBILITY constexpr
        -:  438:        explicit __tuple_leaf(integral_constant<int, 2>, const _Alloc& __a, _Tp&& __t)
        -:  439:            : _Hp(_VSTD::forward<_Tp>(__t), __a) {}
        -:  440:
        -:  441:    __tuple_leaf(__tuple_leaf const &) = default;
        -:  442:    __tuple_leaf(__tuple_leaf &&) = default;
        -:  443:
        -:  444:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  445:    int
        -:  446:    swap(__tuple_leaf& __t) _NOEXCEPT_(__is_nothrow_swappable<__tuple_leaf>::value)
        -:  447:    {
        -:  448:        _VSTD::swap(*this, __t);
        -:  449:        return 0;
        -:  450:    }
        -:  451:
        -:  452:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  453:    int swap(const __tuple_leaf& __rhs) const _NOEXCEPT_(__is_nothrow_swappable<const __tuple_leaf>::value) {
        -:  454:        _VSTD::swap(*this, __rhs);
        -:  455:        return 0;
        -:  456:    }
        -:  457:
        -:  458:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14       _Hp& get()       _NOEXCEPT {return static_cast<_Hp&>(*this);}
        -:  459:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14 const _Hp& get() const _NOEXCEPT {return static_cast<const _Hp&>(*this);}
        -:  460:};
        -:  461:
        -:  462:template <class ..._Tp>
        -:  463:_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
    #####:  464:void __swallow(_Tp&&...) _NOEXCEPT {}
        -:  465:
        -:  466:template <class _Tp>
        -:  467:struct __all_default_constructible;
        -:  468:
        -:  469:template <class ..._Tp>
        -:  470:struct __all_default_constructible<__tuple_types<_Tp...>>
        -:  471:    : __all<is_default_constructible<_Tp>::value...>
        -:  472:{ };
        -:  473:
        -:  474:// __tuple_impl
        -:  475:
        -:  476:template<class _Indx, class ..._Tp> struct __tuple_impl;
        -:  477:
        -:  478:template<size_t ..._Indx, class ..._Tp>
        -:  479:struct _LIBCPP_DECLSPEC_EMPTY_BASES __tuple_impl<__tuple_indices<_Indx...>, _Tp...>
        -:  480:    : public __tuple_leaf<_Indx, _Tp>...
        -:  481:{
        -:  482:    _LIBCPP_INLINE_VISIBILITY
    #####:  483:    constexpr __tuple_impl()
    #####:  484:        _NOEXCEPT_(__all<is_nothrow_default_constructible<_Tp>::value...>::value) {}
        -:  485:
        -:  486:    template <size_t ..._Uf, class ..._Tf,
        -:  487:              size_t ..._Ul, class ..._Tl, class ..._Up>
        -:  488:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  489:        explicit
    #####:  490:        __tuple_impl(__tuple_indices<_Uf...>, __tuple_types<_Tf...>,
        -:  491:                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
        -:  492:                     _Up&&... __u)
        -:  493:                     _NOEXCEPT_((__all<is_nothrow_constructible<_Tf, _Up>::value...>::value &&
        -:  494:                                 __all<is_nothrow_default_constructible<_Tl>::value...>::value)) :
    #####:  495:            __tuple_leaf<_Uf, _Tf>(_VSTD::forward<_Up>(__u))...,
        -:  496:            __tuple_leaf<_Ul, _Tl>()...
    #####:  497:            {}
        -:  498:
        -:  499:    template <class _Alloc, size_t ..._Uf, class ..._Tf,
        -:  500:              size_t ..._Ul, class ..._Tl, class ..._Up>
        -:  501:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  502:        explicit
        -:  503:        __tuple_impl(allocator_arg_t, const _Alloc& __a,
        -:  504:                     __tuple_indices<_Uf...>, __tuple_types<_Tf...>,
        -:  505:                     __tuple_indices<_Ul...>, __tuple_types<_Tl...>,
        -:  506:                     _Up&&... __u) :
        -:  507:            __tuple_leaf<_Uf, _Tf>(__uses_alloc_ctor<_Tf, _Alloc, _Up>(), __a,
        -:  508:            _VSTD::forward<_Up>(__u))...,
        -:  509:            __tuple_leaf<_Ul, _Tl>(__uses_alloc_ctor<_Tl, _Alloc>(), __a)...
        -:  510:            {}
        -:  511:
        -:  512:    template <class _Tuple,
        -:  513:              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
        -:  514:             >
        -:  515:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  516:        __tuple_impl(_Tuple&& __t) _NOEXCEPT_((__all<is_nothrow_constructible<_Tp, typename tuple_element<_Indx,
        -:  517:                                       typename __make_tuple_types<_Tuple>::type>::type>::value...>::value))
        -:  518:            : __tuple_leaf<_Indx, _Tp>(_VSTD::forward<typename tuple_element<_Indx,
        -:  519:                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...
        -:  520:            {}
        -:  521:
        -:  522:    template <class _Alloc, class _Tuple,
        -:  523:              class = __enable_if_t<__tuple_constructible<_Tuple, tuple<_Tp...> >::value>
        -:  524:             >
        -:  525:        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  526:        __tuple_impl(allocator_arg_t, const _Alloc& __a, _Tuple&& __t)
        -:  527:            : __tuple_leaf<_Indx, _Tp>(__uses_alloc_ctor<_Tp, _Alloc, typename tuple_element<_Indx,
        -:  528:                                       typename __make_tuple_types<_Tuple>::type>::type>(), __a,
        -:  529:                                       _VSTD::forward<typename tuple_element<_Indx,
        -:  530:                                       typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<_Indx>(__t)))...
        -:  531:            {}
        -:  532:
        -:  533:    __tuple_impl(const __tuple_impl&) = default;
        -:  534:    __tuple_impl(__tuple_impl&&) = default;
        -:  535:
        -:  536:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  537:    void swap(__tuple_impl& __t)
        -:  538:        _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        -:  539:    {
        -:  540:        _VSTD::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<__tuple_leaf<_Indx, _Tp>&>(__t))...);
        -:  541:    }
        -:  542:
        -:  543:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  544:    void swap(const __tuple_impl& __t) const
        -:  545:        _NOEXCEPT_(__all<__is_nothrow_swappable<const _Tp>::value...>::value)
        -:  546:    {
        -:  547:        _VSTD::__swallow(__tuple_leaf<_Indx, _Tp>::swap(static_cast<const __tuple_leaf<_Indx, _Tp>&>(__t))...);
        -:  548:    }
        -:  549:};
        -:  550:
        -:  551:template<class _Dest, class _Source, size_t ..._Np>
        -:  552:_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  553:void __memberwise_copy_assign(_Dest& __dest, _Source const& __source, __tuple_indices<_Np...>) {
        -:  554:    _VSTD::__swallow(((_VSTD::get<_Np>(__dest) = _VSTD::get<_Np>(__source)), void(), 0)...);
        -:  555:}
        -:  556:
        -:  557:template<class _Dest, class _Source, class ..._Up, size_t ..._Np>
        -:  558:_LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
    #####:  559:void __memberwise_forward_assign(_Dest& __dest, _Source&& __source, __tuple_types<_Up...>, __tuple_indices<_Np...>) {
    #####:  560:    _VSTD::__swallow(((
    #####:  561:        _VSTD::get<_Np>(__dest) = _VSTD::forward<_Up>(_VSTD::get<_Np>(__source))
        -:  562:    ), void(), 0)...);
    #####:  563:}
        -:  564:
        -:  565:template <class ..._Tp>
        -:  566:class _LIBCPP_TEMPLATE_VIS tuple
        -:  567:{
        -:  568:    typedef __tuple_impl<typename __make_tuple_indices<sizeof...(_Tp)>::type, _Tp...> _BaseT;
        -:  569:
        -:  570:    _BaseT __base_;
        -:  571:
        -:  572:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  573:        typename tuple_element<_Jp, tuple<_Up...> >::type& get(tuple<_Up...>&) _NOEXCEPT;
        -:  574:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  575:        const typename tuple_element<_Jp, tuple<_Up...> >::type& get(const tuple<_Up...>&) _NOEXCEPT;
        -:  576:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  577:        typename tuple_element<_Jp, tuple<_Up...> >::type&& get(tuple<_Up...>&&) _NOEXCEPT;
        -:  578:    template <size_t _Jp, class ..._Up> friend _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  579:        const typename tuple_element<_Jp, tuple<_Up...> >::type&& get(const tuple<_Up...>&&) _NOEXCEPT;
        -:  580:public:
        -:  581:    // [tuple.cnstr]
        -:  582:
        -:  583:    // tuple() constructors (including allocator_arg_t variants)
        -:  584:    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        -:  585:        _And<
        -:  586:            _IsImpDefault<_Tp>... // explicit check
        -:  587:        >::value
        -:  588:    , int> = 0>
        -:  589:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
    #####:  590:    tuple()
        -:  591:        _NOEXCEPT_(_And<is_nothrow_default_constructible<_Tp>...>::value)
    #####:  592:    { }
        -:  593:
        -:  594:    template <template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
        -:  595:              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        -:  596:        _And<
        -:  597:            _IsDefault<_Tp>...,
        -:  598:            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> > // explicit check
        -:  599:        >::value
        -:  600:    , int> = 0>
        -:  601:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR
        -:  602:    explicit tuple()
        -:  603:        _NOEXCEPT_(_And<is_nothrow_default_constructible<_Tp>...>::value)
        -:  604:    { }
        -:  605:
        -:  606:    template <class _Alloc, template<class...> class _IsImpDefault = __is_implicitly_default_constructible, __enable_if_t<
        -:  607:        _And<
        -:  608:            _IsImpDefault<_Tp>... // explicit check
        -:  609:        >::value
        -:  610:    , int> = 0>
        -:  611:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  612:    tuple(allocator_arg_t, _Alloc const& __a)
        -:  613:      : __base_(allocator_arg_t(), __a,
        -:  614:                    __tuple_indices<>(), __tuple_types<>(),
        -:  615:                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
        -:  616:                    __tuple_types<_Tp...>()) {}
        -:  617:
        -:  618:    template <class _Alloc,
        -:  619:              template<class...> class _IsImpDefault = __is_implicitly_default_constructible,
        -:  620:              template<class...> class _IsDefault = is_default_constructible, __enable_if_t<
        -:  621:        _And<
        -:  622:            _IsDefault<_Tp>...,
        -:  623:            _Not<_Lazy<_And, _IsImpDefault<_Tp>...> > // explicit check
        -:  624:        >::value
        -:  625:    , int> = 0>
        -:  626:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  627:    explicit tuple(allocator_arg_t, _Alloc const& __a)
        -:  628:      : __base_(allocator_arg_t(), __a,
        -:  629:                    __tuple_indices<>(), __tuple_types<>(),
        -:  630:                    typename __make_tuple_indices<sizeof...(_Tp), 0>::type(),
        -:  631:                    __tuple_types<_Tp...>()) {}
        -:  632:
        -:  633:    // tuple(const T&...) constructors (including allocator_arg_t variants)
        -:  634:    template <template<class...> class _And = _And, __enable_if_t<
        -:  635:        _And<
        -:  636:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  637:            is_copy_constructible<_Tp>...,
        -:  638:            is_convertible<const _Tp&, _Tp>... // explicit check
        -:  639:        >::value
        -:  640:    , int> = 0>
        -:  641:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  642:    tuple(const _Tp& ... __t)
        -:  643:        _NOEXCEPT_(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        -:  644:        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  645:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  646:                typename __make_tuple_indices<0>::type(),
        -:  647:                typename __make_tuple_types<tuple, 0>::type(),
        -:  648:                __t...
        -:  649:               ) {}
        -:  650:
        -:  651:    template <template<class...> class _And = _And, __enable_if_t<
        -:  652:        _And<
        -:  653:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  654:            is_copy_constructible<_Tp>...,
        -:  655:            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> > // explicit check
        -:  656:        >::value
        -:  657:    , int> = 0>
        -:  658:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  659:    explicit tuple(const _Tp& ... __t)
        -:  660:        _NOEXCEPT_(_And<is_nothrow_copy_constructible<_Tp>...>::value)
        -:  661:        : __base_(typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  662:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  663:                typename __make_tuple_indices<0>::type(),
        -:  664:                typename __make_tuple_types<tuple, 0>::type(),
        -:  665:                __t...
        -:  666:               ) {}
        -:  667:
        -:  668:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  669:        _And<
        -:  670:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  671:            is_copy_constructible<_Tp>...,
        -:  672:            is_convertible<const _Tp&, _Tp>... // explicit check
        -:  673:        >::value
        -:  674:    , int> = 0>
        -:  675:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  676:    tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        -:  677:        : __base_(allocator_arg_t(), __a,
        -:  678:                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  679:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  680:                typename __make_tuple_indices<0>::type(),
        -:  681:                typename __make_tuple_types<tuple, 0>::type(),
        -:  682:                __t...
        -:  683:               ) {}
        -:  684:
        -:  685:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  686:        _And<
        -:  687:            _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  688:            is_copy_constructible<_Tp>...,
        -:  689:            _Not<_Lazy<_And, is_convertible<const _Tp&, _Tp>...> > // explicit check
        -:  690:        >::value
        -:  691:    , int> = 0>
        -:  692:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  693:    explicit tuple(allocator_arg_t, const _Alloc& __a, const _Tp& ... __t)
        -:  694:        : __base_(allocator_arg_t(), __a,
        -:  695:                typename __make_tuple_indices<sizeof...(_Tp)>::type(),
        -:  696:                typename __make_tuple_types<tuple, sizeof...(_Tp)>::type(),
        -:  697:                typename __make_tuple_indices<0>::type(),
        -:  698:                typename __make_tuple_types<tuple, 0>::type(),
        -:  699:                __t...
        -:  700:               ) {}
        -:  701:
        -:  702:    // tuple(U&& ...) constructors (including allocator_arg_t variants)
        -:  703:    template <class ..._Up> struct _IsThisTuple : false_type { };
        -:  704:    template <class _Up> struct _IsThisTuple<_Up> : is_same<__remove_cvref_t<_Up>, tuple> { };
        -:  705:
        -:  706:    template <class ..._Up>
        -:  707:    struct _EnableUTypesCtor : _And<
        -:  708:        _BoolConstant<sizeof...(_Tp) >= 1>,
        -:  709:        _Not<_IsThisTuple<_Up...> >, // extension to allow mis-behaved user constructors
        -:  710:        is_constructible<_Tp, _Up>...
        -:  711:    > { };
        -:  712:
        -:  713:    template <class ..._Up, __enable_if_t<
        -:  714:        _And<
        -:  715:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  716:            _EnableUTypesCtor<_Up...>,
        -:  717:            is_convertible<_Up, _Tp>... // explicit check
        -:  718:        >::value
        -:  719:    , int> = 0>
        -:  720:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
    #####:  721:    tuple(_Up&&... __u)
        -:  722:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
    #####:  723:        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  724:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  725:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  726:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
    #####:  727:                    _VSTD::forward<_Up>(__u)...) {}
        -:  728:
        -:  729:    template <class ..._Up, __enable_if_t<
        -:  730:        _And<
        -:  731:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  732:            _EnableUTypesCtor<_Up...>,
        -:  733:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  734:        >::value
        -:  735:    , int> = 0>
        -:  736:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  737:    explicit tuple(_Up&&... __u)
        -:  738:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  739:        : __base_(typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  740:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  741:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  742:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  743:                    _VSTD::forward<_Up>(__u)...) {}
        -:  744:
        -:  745:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  746:        _And<
        -:  747:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  748:            _EnableUTypesCtor<_Up...>,
        -:  749:            is_convertible<_Up, _Tp>... // explicit check
        -:  750:        >::value
        -:  751:    , int> = 0>
        -:  752:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  753:    tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        -:  754:        : __base_(allocator_arg_t(), __a,
        -:  755:                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  756:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  757:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  758:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  759:                    _VSTD::forward<_Up>(__u)...) {}
        -:  760:
        -:  761:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  762:        _And<
        -:  763:            _BoolConstant<sizeof...(_Up) == sizeof...(_Tp)>,
        -:  764:            _EnableUTypesCtor<_Up...>,
        -:  765:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  766:        >::value
        -:  767:    , int> = 0>
        -:  768:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  769:    explicit tuple(allocator_arg_t, const _Alloc& __a, _Up&&... __u)
        -:  770:        : __base_(allocator_arg_t(), __a,
        -:  771:                    typename __make_tuple_indices<sizeof...(_Up)>::type(),
        -:  772:                    typename __make_tuple_types<tuple, sizeof...(_Up)>::type(),
        -:  773:                    typename __make_tuple_indices<sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  774:                    typename __make_tuple_types<tuple, sizeof...(_Tp), sizeof...(_Up)>::type(),
        -:  775:                    _VSTD::forward<_Up>(__u)...) {}
        -:  776:
        -:  777:    // Copy and move constructors (including the allocator_arg_t variants)
        -:  778:    tuple(const tuple&) = default;
        -:  779:    tuple(tuple&&) = default;
        -:  780:
        -:  781:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  782:        _And<is_copy_constructible<_Tp>...>::value
        -:  783:    , int> = 0>
        -:  784:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  785:    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple& __t)
        -:  786:        : __base_(allocator_arg_t(), __alloc, __t)
        -:  787:    { }
        -:  788:
        -:  789:    template <class _Alloc, template<class...> class _And = _And, __enable_if_t<
        -:  790:        _And<is_move_constructible<_Tp>...>::value
        -:  791:    , int> = 0>
        -:  792:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  793:    tuple(allocator_arg_t, const _Alloc& __alloc, tuple&& __t)
        -:  794:        : __base_(allocator_arg_t(), __alloc, _VSTD::move(__t))
        -:  795:    { }
        -:  796:
        -:  797:    // tuple(const tuple<U...>&) constructors (including allocator_arg_t variants)
        -:  798:
        -:  799:    template <class _OtherTuple, class _DecayedOtherTuple = __remove_cvref_t<_OtherTuple>, class = void>
        -:  800:    struct _EnableCtorFromUTypesTuple : false_type {};
        -:  801:
        -:  802:    template <class _OtherTuple, class... _Up>
        -:  803:    struct _EnableCtorFromUTypesTuple<_OtherTuple, tuple<_Up...>,
        -:  804:              // the length of the packs needs to checked first otherwise the 2 packs cannot be expanded simultaneously below
        -:  805:               __enable_if_t<sizeof...(_Up) == sizeof...(_Tp)>> : _And<
        -:  806:        // the two conditions below are not in spec. The purpose is to disable the UTypes Ctor when copy/move Ctor can work.
        -:  807:        // Otherwise, is_constructible can trigger hard error in those cases https://godbolt.org/z/M94cGdKcE
        -:  808:        _Not<is_same<_OtherTuple, const tuple&> >,
        -:  809:        _Not<is_same<_OtherTuple, tuple&&> >,
        -:  810:        is_constructible<_Tp, __copy_cvref_t<_OtherTuple, _Up> >...,
        -:  811:        _Lazy<_Or, _BoolConstant<sizeof...(_Tp) != 1>,
        -:  812:            // _Tp and _Up are 1-element packs - the pack expansions look
        -:  813:            // weird to avoid tripping up the type traits in degenerate cases
        -:  814:            _Lazy<_And,
        -:  815:                _Not<is_same<_Tp, _Up> >...,
        -:  816:                _Not<is_convertible<_OtherTuple, _Tp> >...,
        -:  817:                _Not<is_constructible<_Tp, _OtherTuple> >...
        -:  818:            >
        -:  819:        >
        -:  820:    > {};
        -:  821:
        -:  822:    template <class ..._Up, __enable_if_t<
        -:  823:        _And<
        -:  824:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  825:            is_convertible<const _Up&, _Tp>... // explicit check
        -:  826:        >::value
        -:  827:    , int> = 0>
        -:  828:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  829:    tuple(const tuple<_Up...>& __t)
        -:  830:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        -:  831:        : __base_(__t)
        -:  832:    { }
        -:  833:
        -:  834:    template <class ..._Up, __enable_if_t<
        -:  835:        _And<
        -:  836:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  837:            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> > // explicit check
        -:  838:        >::value
        -:  839:    , int> = 0>
        -:  840:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  841:    explicit tuple(const tuple<_Up...>& __t)
        -:  842:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, const _Up&>...>::value))
        -:  843:        : __base_(__t)
        -:  844:    { }
        -:  845:
        -:  846:    template <class ..._Up, class _Alloc, __enable_if_t<
        -:  847:        _And<
        -:  848:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  849:            is_convertible<const _Up&, _Tp>... // explicit check
        -:  850:        >::value
        -:  851:    , int> = 0>
        -:  852:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  853:    tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        -:  854:        : __base_(allocator_arg_t(), __a, __t)
        -:  855:    { }
        -:  856:
        -:  857:    template <class ..._Up, class _Alloc, __enable_if_t<
        -:  858:        _And<
        -:  859:            _EnableCtorFromUTypesTuple<const tuple<_Up...>&>,
        -:  860:            _Not<_Lazy<_And, is_convertible<const _Up&, _Tp>...> > // explicit check
        -:  861:        >::value
        -:  862:    , int> = 0>
        -:  863:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  864:    explicit tuple(allocator_arg_t, const _Alloc& __a, const tuple<_Up...>& __t)
        -:  865:        : __base_(allocator_arg_t(), __a, __t)
        -:  866:    { }
        -:  867:
        -:  868:#if _LIBCPP_STD_VER > 20
        -:  869:    // tuple(tuple<U...>&) constructors (including allocator_arg_t variants)
        -:  870:
        -:  871:    template <class... _Up, enable_if_t<
        -:  872:        _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
        -:  873:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  874:        explicit(!(is_convertible_v<_Up&, _Tp> && ...))
        -:  875:    tuple(tuple<_Up...>& __t) : __base_(__t) {}
        -:  876:
        -:  877:    template <class _Alloc, class... _Up, enable_if_t<
        -:  878:        _EnableCtorFromUTypesTuple<tuple<_Up...>&>::value>* = nullptr>
        -:  879:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  880:        explicit(!(is_convertible_v<_Up&, _Tp> && ...))
        -:  881:    tuple(allocator_arg_t, const _Alloc& __alloc, tuple<_Up...>& __t) : __base_(allocator_arg_t(), __alloc, __t) {}
        -:  882:#endif // _LIBCPP_STD_VER > 20
        -:  883:
        -:  884:    // tuple(tuple<U...>&&) constructors (including allocator_arg_t variants)
        -:  885:
        -:  886:    template <class ..._Up, __enable_if_t<
        -:  887:        _And<
        -:  888:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  889:            is_convertible<_Up, _Tp>... // explicit check
        -:  890:        >::value
        -:  891:    , int> = 0>
        -:  892:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  893:    tuple(tuple<_Up...>&& __t)
        -:  894:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  895:        : __base_(_VSTD::move(__t))
        -:  896:    { }
        -:  897:
        -:  898:    template <class ..._Up, __enable_if_t<
        -:  899:        _And<
        -:  900:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  901:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  902:        >::value
        -:  903:    , int> = 0>
        -:  904:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  905:    explicit tuple(tuple<_Up...>&& __t)
        -:  906:        _NOEXCEPT_((_And<is_nothrow_constructible<_Tp, _Up>...>::value))
        -:  907:        : __base_(_VSTD::move(__t))
        -:  908:    { }
        -:  909:
        -:  910:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  911:        _And<
        -:  912:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  913:            is_convertible<_Up, _Tp>... // explicit check
        -:  914:        >::value
        -:  915:    , int> = 0>
        -:  916:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  917:    tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        -:  918:        : __base_(allocator_arg_t(), __a, _VSTD::move(__t))
        -:  919:    { }
        -:  920:
        -:  921:    template <class _Alloc, class ..._Up, __enable_if_t<
        -:  922:        _And<
        -:  923:            _EnableCtorFromUTypesTuple<tuple<_Up...>&&>,
        -:  924:            _Not<_Lazy<_And, is_convertible<_Up, _Tp>...> > // explicit check
        -:  925:        >::value
        -:  926:    , int> = 0>
        -:  927:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -:  928:    explicit tuple(allocator_arg_t, const _Alloc& __a, tuple<_Up...>&& __t)
        -:  929:        : __base_(allocator_arg_t(), __a, _VSTD::move(__t))
        -:  930:    { }
        -:  931:
        -:  932:#if _LIBCPP_STD_VER > 20
        -:  933:    // tuple(const tuple<U...>&&) constructors (including allocator_arg_t variants)
        -:  934:
        -:  935:    template <class... _Up, enable_if_t<
        -:  936:        _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
        -:  937:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  938:        explicit(!(is_convertible_v<const _Up&&, _Tp> && ...))
        -:  939:    tuple(const tuple<_Up...>&& __t) : __base_(std::move(__t)) {}
        -:  940:
        -:  941:    template <class _Alloc, class... _Up, enable_if_t<
        -:  942:        _EnableCtorFromUTypesTuple<const tuple<_Up...>&&>::value>* = nullptr>
        -:  943:    _LIBCPP_HIDE_FROM_ABI constexpr
        -:  944:        explicit(!(is_convertible_v<const _Up&&, _Tp> && ...))
        -:  945:    tuple(allocator_arg_t, const _Alloc& __alloc, const tuple<_Up...>&& __t)
        -:  946:        : __base_(allocator_arg_t(), __alloc, std::move(__t)) {}
        -:  947:#endif // _LIBCPP_STD_VER > 20
        -:  948:
        -:  949:    // tuple(const pair<U1, U2>&) constructors (including allocator_arg_t variants)
        -:  950:
        -:  951:    template <template <class...> class Pred, class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -:  952:    struct _CtorPredicateFromPair : false_type{};
        -:  953:
        -:  954:    template <template <class...> class Pred, class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  955:    struct _CtorPredicateFromPair<Pred, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        -:  956:        Pred<_Tp1, __copy_cvref_t<_Pair, _Up1> >,
        -:  957:        Pred<_Tp2, __copy_cvref_t<_Pair, _Up2> >
        -:  958:    > {};
        -:  959:
        -:  960:    template <class _Pair>
        -:  961:    struct _EnableCtorFromPair : _CtorPredicateFromPair<is_constructible, _Pair>{};
        -:  962:
        -:  963:    template <class _Pair>
        -:  964:    struct _NothrowConstructibleFromPair : _CtorPredicateFromPair<is_nothrow_constructible, _Pair>{};
        -:  965:
        -:  966:    template <class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -:  967:    struct _BothImplicitlyConvertible : false_type{};
        -:  968:
        -:  969:    template <class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -:  970:    struct _BothImplicitlyConvertible<_Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > : _And<
        -:  971:        is_convertible<__copy_cvref_t<_Pair, _Up1>, _Tp1>,
        -:  972:        is_convertible<__copy_cvref_t<_Pair, _Up2>, _Tp2>
        -:  973:    > {};
        -:  974:
        -:  975:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -:  976:        _And<
        -:  977:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -:  978:            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&> // explicit check
        -:  979:        >::value
        -:  980:    , int> = 0>
        -:  981:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  982:    tuple(const pair<_Up1, _Up2>& __p)
        -:  983:        _NOEXCEPT_((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        -:  984:        : __base_(__p)
        -:  985:    { }
        -:  986:
        -:  987:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -:  988:        _And<
        -:  989:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -:  990:            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> > // explicit check
        -:  991:        >::value
        -:  992:    , int> = 0>
        -:  993:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -:  994:    explicit tuple(const pair<_Up1, _Up2>& __p)
        -:  995:        _NOEXCEPT_((_NothrowConstructibleFromPair<const pair<_Up1, _Up2>&>::value))
        -:  996:        : __base_(__p)
        -:  997:    { }
        -:  998:
        -:  999:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1000:        _And<
        -: 1001:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -: 1002:            _BothImplicitlyConvertible<const pair<_Up1, _Up2>&> // explicit check
        -: 1003:        >::value
        -: 1004:    , int> = 0>
        -: 1005:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1006:    tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        -: 1007:        : __base_(allocator_arg_t(), __a, __p)
        -: 1008:    { }
        -: 1009:
        -: 1010:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1011:        _And<
        -: 1012:            _EnableCtorFromPair<const pair<_Up1, _Up2>&>,
        -: 1013:            _Not<_BothImplicitlyConvertible<const pair<_Up1, _Up2>&> > // explicit check
        -: 1014:        >::value
        -: 1015:    , int> = 0>
        -: 1016:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1017:    explicit tuple(allocator_arg_t, const _Alloc& __a, const pair<_Up1, _Up2>& __p)
        -: 1018:        : __base_(allocator_arg_t(), __a, __p)
        -: 1019:    { }
        -: 1020:
        -: 1021:#if _LIBCPP_STD_VER > 20
        -: 1022:    // tuple(pair<U1, U2>&) constructors (including allocator_arg_t variants)
        -: 1023:
        -: 1024:    template <class _U1, class _U2, enable_if_t<
        -: 1025:        _EnableCtorFromPair<pair<_U1, _U2>&>::value>* = nullptr>
        -: 1026:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1027:        explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
        -: 1028:    tuple(pair<_U1, _U2>& __p) : __base_(__p) {}
        -: 1029:
        -: 1030:    template <class _Alloc, class _U1, class _U2, enable_if_t<
        -: 1031:        _EnableCtorFromPair<std::pair<_U1, _U2>&>::value>* = nullptr>
        -: 1032:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1033:        explicit(!_BothImplicitlyConvertible<pair<_U1, _U2>&>::value)
        -: 1034:    tuple(allocator_arg_t, const _Alloc& __alloc, pair<_U1, _U2>& __p) : __base_(allocator_arg_t(), __alloc, __p) {}
        -: 1035:#endif
        -: 1036:
        -: 1037:    // tuple(pair<U1, U2>&&) constructors (including allocator_arg_t variants)
        -: 1038:
        -: 1039:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1040:        _And<
        -: 1041:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1042:            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&> // explicit check
        -: 1043:        >::value
        -: 1044:    , int> = 0>
        -: 1045:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1046:    tuple(pair<_Up1, _Up2>&& __p)
        -: 1047:        _NOEXCEPT_((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        -: 1048:        : __base_(_VSTD::move(__p))
        -: 1049:    { }
        -: 1050:
        -: 1051:    template <class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1052:        _And<
        -: 1053:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1054:            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> > // explicit check
        -: 1055:        >::value
        -: 1056:    , int> = 0>
        -: 1057:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1058:    explicit tuple(pair<_Up1, _Up2>&& __p)
        -: 1059:        _NOEXCEPT_((_NothrowConstructibleFromPair<pair<_Up1, _Up2>&&>::value))
        -: 1060:        : __base_(_VSTD::move(__p))
        -: 1061:    { }
        -: 1062:
        -: 1063:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1064:        _And<
        -: 1065:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1066:            _BothImplicitlyConvertible<pair<_Up1, _Up2>&&> // explicit check
        -: 1067:        >::value
        -: 1068:    , int> = 0>
        -: 1069:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1070:    tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        -: 1071:        : __base_(allocator_arg_t(), __a, _VSTD::move(__p))
        -: 1072:    { }
        -: 1073:
        -: 1074:    template <class _Alloc, class _Up1, class _Up2, template<class...> class _And = _And, __enable_if_t<
        -: 1075:        _And<
        -: 1076:            _EnableCtorFromPair<pair<_Up1, _Up2>&&>,
        -: 1077:            _Not<_BothImplicitlyConvertible<pair<_Up1, _Up2>&&> > // explicit check
        -: 1078:        >::value
        -: 1079:    , int> = 0>
        -: 1080:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1081:    explicit tuple(allocator_arg_t, const _Alloc& __a, pair<_Up1, _Up2>&& __p)
        -: 1082:        : __base_(allocator_arg_t(), __a, _VSTD::move(__p))
        -: 1083:    { }
        -: 1084:
        -: 1085:#if _LIBCPP_STD_VER > 20
        -: 1086:    // tuple(const pair<U1, U2>&&) constructors (including allocator_arg_t variants)
        -: 1087:
        -: 1088:    template <class _U1, class _U2, enable_if_t<
        -: 1089:        _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
        -: 1090:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1091:        explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
        -: 1092:    tuple(const pair<_U1, _U2>&& __p) : __base_(std::move(__p)) {}
        -: 1093:
        -: 1094:    template <class _Alloc, class _U1, class _U2, enable_if_t<
        -: 1095:        _EnableCtorFromPair<const pair<_U1, _U2>&&>::value>* = nullptr>
        -: 1096:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1097:        explicit(!_BothImplicitlyConvertible<const pair<_U1, _U2>&&>::value)
        -: 1098:    tuple(allocator_arg_t, const _Alloc& __alloc, const pair<_U1, _U2>&& __p)
        -: 1099:        : __base_(allocator_arg_t(), __alloc, std::move(__p)) {}
        -: 1100:#endif // _LIBCPP_STD_VER > 20
        -: 1101:
        -: 1102:    // [tuple.assign]
        -: 1103:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1104:    tuple& operator=(_If<_And<is_copy_assignable<_Tp>...>::value, tuple, __nat> const& __tuple)
        -: 1105:        _NOEXCEPT_((_And<is_nothrow_copy_assignable<_Tp>...>::value))
        -: 1106:    {
        -: 1107:        _VSTD::__memberwise_copy_assign(*this, __tuple,
        -: 1108:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1109:        return *this;
        -: 1110:    }
        -: 1111:
        -: 1112:#if _LIBCPP_STD_VER > 20
        -: 1113:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1114:    const tuple& operator=(tuple const& __tuple) const
        -: 1115:      requires (_And<is_copy_assignable<const _Tp>...>::value) {
        -: 1116:        std::__memberwise_copy_assign(*this, __tuple, typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1117:        return *this;
        -: 1118:    }
        -: 1119:
        -: 1120:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1121:    const tuple& operator=(tuple&& __tuple) const
        -: 1122:      requires (_And<is_assignable<const _Tp&, _Tp>...>::value) {
        -: 1123:        std::__memberwise_forward_assign(*this,
        -: 1124:                                         std::move(__tuple),
        -: 1125:                                         __tuple_types<_Tp...>(),
        -: 1126:                                         typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1127:        return *this;
        -: 1128:    }
        -: 1129:#endif // _LIBCPP_STD_VER > 20
        -: 1130:
        -: 1131:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
    #####: 1132:    tuple& operator=(_If<_And<is_move_assignable<_Tp>...>::value, tuple, __nat>&& __tuple)
        -: 1133:        _NOEXCEPT_((_And<is_nothrow_move_assignable<_Tp>...>::value))
        -: 1134:    {
    #####: 1135:        _VSTD::__memberwise_forward_assign(*this, _VSTD::move(__tuple),
        -: 1136:            __tuple_types<_Tp...>(),
        -: 1137:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
    #####: 1138:        return *this;
        -: 1139:    }
        -: 1140:
        -: 1141:    template<class... _Up, __enable_if_t<
        -: 1142:        _And<
        -: 1143:            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
        -: 1144:            is_assignable<_Tp&, _Up const&>...
        -: 1145:        >::value
        -: 1146:    ,int> = 0>
        -: 1147:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1148:    tuple& operator=(tuple<_Up...> const& __tuple)
        -: 1149:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
        -: 1150:    {
        -: 1151:        _VSTD::__memberwise_copy_assign(*this, __tuple,
        -: 1152:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1153:        return *this;
        -: 1154:    }
        -: 1155:
        -: 1156:    template<class... _Up, __enable_if_t<
        -: 1157:        _And<
        -: 1158:            _BoolConstant<sizeof...(_Tp) == sizeof...(_Up)>,
        -: 1159:            is_assignable<_Tp&, _Up>...
        -: 1160:        >::value
        -: 1161:    ,int> = 0>
        -: 1162:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1163:    tuple& operator=(tuple<_Up...>&& __tuple)
        -: 1164:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
        -: 1165:    {
        -: 1166:        _VSTD::__memberwise_forward_assign(*this, _VSTD::move(__tuple),
        -: 1167:            __tuple_types<_Up...>(),
        -: 1168:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1169:        return *this;
        -: 1170:    }
        -: 1171:
        -: 1172:
        -: 1173:#if _LIBCPP_STD_VER > 20
        -: 1174:    template <class... _UTypes, enable_if_t<
        -: 1175:        _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
        -: 1176:             is_assignable<const _Tp&, const _UTypes&>...>::value>* = nullptr>
        -: 1177:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1178:    const tuple& operator=(const tuple<_UTypes...>& __u) const {
        -: 1179:        std::__memberwise_copy_assign(*this,
        -: 1180:                                      __u,
        -: 1181:                                      typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1182:        return *this;
        -: 1183:    }
        -: 1184:
        -: 1185:    template <class... _UTypes, enable_if_t<
        -: 1186:        _And<_BoolConstant<sizeof...(_Tp) == sizeof...(_UTypes)>,
        -: 1187:             is_assignable<const _Tp&, _UTypes>...>::value>* = nullptr>
        -: 1188:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1189:    const tuple& operator=(tuple<_UTypes...>&& __u) const {
        -: 1190:        std::__memberwise_forward_assign(*this,
        -: 1191:                                         __u,
        -: 1192:                                         __tuple_types<_UTypes...>(),
        -: 1193:                                         typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1194:        return *this;
        -: 1195:    }
        -: 1196:#endif // _LIBCPP_STD_VER > 20
        -: 1197:
        -: 1198:    template <template<class...> class Pred, bool _Const,
        -: 1199:              class _Pair, class _DecayedPair = __remove_cvref_t<_Pair>, class _Tuple = tuple>
        -: 1200:    struct _AssignPredicateFromPair : false_type {};
        -: 1201:
        -: 1202:    template <template<class...> class Pred, bool _Const,
        -: 1203:              class _Pair, class _Up1, class _Up2, class _Tp1, class _Tp2>
        -: 1204:    struct _AssignPredicateFromPair<Pred, _Const, _Pair, pair<_Up1, _Up2>, tuple<_Tp1, _Tp2> > :
        -: 1205:        _And<Pred<__maybe_const<_Const, _Tp1>&, __copy_cvref_t<_Pair, _Up1> >,
        -: 1206:             Pred<__maybe_const<_Const, _Tp2>&, __copy_cvref_t<_Pair, _Up2> >
        -: 1207:            > {};
        -: 1208:
        -: 1209:    template <bool _Const, class _Pair>
        -: 1210:    struct _EnableAssignFromPair : _AssignPredicateFromPair<is_assignable, _Const, _Pair> {};
        -: 1211:
        -: 1212:    template <bool _Const, class _Pair>
        -: 1213:    struct _NothrowAssignFromPair : _AssignPredicateFromPair<is_nothrow_assignable, _Const, _Pair> {};
        -: 1214:
        -: 1215:#if _LIBCPP_STD_VER > 20
        -: 1216:    template <class _U1, class _U2, enable_if_t<
        -: 1217:        _EnableAssignFromPair<true, const pair<_U1, _U2>&>::value>* = nullptr>
        -: 1218:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1219:    const tuple& operator=(const pair<_U1, _U2>& __pair) const
        -: 1220:      noexcept(_NothrowAssignFromPair<true, const pair<_U1, _U2>&>::value) {
        -: 1221:        std::get<0>(*this) = __pair.first;
        -: 1222:        std::get<1>(*this) = __pair.second;
        -: 1223:        return *this;
        -: 1224:    }
        -: 1225:
        -: 1226:    template <class _U1, class _U2, enable_if_t<
        -: 1227:        _EnableAssignFromPair<true, pair<_U1, _U2>&&>::value>* = nullptr>
        -: 1228:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1229:    const tuple& operator=(pair<_U1, _U2>&& __pair) const
        -: 1230:      noexcept(_NothrowAssignFromPair<true, pair<_U1, _U2>&&>::value) {
        -: 1231:        std::get<0>(*this) = std::move(__pair.first);
        -: 1232:        std::get<1>(*this) = std::move(__pair.second);
        -: 1233:        return *this;
        -: 1234:    }
        -: 1235:#endif // _LIBCPP_STD_VER > 20
        -: 1236:
        -: 1237:    template<class _Up1, class _Up2, __enable_if_t<
        -: 1238:        _EnableAssignFromPair<false, pair<_Up1, _Up2> const&>::value
        -: 1239:    ,int> = 0>
        -: 1240:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1241:    tuple& operator=(pair<_Up1, _Up2> const& __pair)
        -: 1242:        _NOEXCEPT_((_NothrowAssignFromPair<false, pair<_Up1, _Up2> const&>::value))
        -: 1243:    {
        -: 1244:        _VSTD::get<0>(*this) = __pair.first;
        -: 1245:        _VSTD::get<1>(*this) = __pair.second;
        -: 1246:        return *this;
        -: 1247:    }
        -: 1248:
        -: 1249:    template<class _Up1, class _Up2, __enable_if_t<
        -: 1250:        _EnableAssignFromPair<false, pair<_Up1, _Up2>&&>::value
        -: 1251:    ,int> = 0>
        -: 1252:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1253:    tuple& operator=(pair<_Up1, _Up2>&& __pair)
        -: 1254:        _NOEXCEPT_((_NothrowAssignFromPair<false, pair<_Up1, _Up2>&&>::value))
        -: 1255:    {
        -: 1256:        _VSTD::get<0>(*this) = _VSTD::forward<_Up1>(__pair.first);
        -: 1257:        _VSTD::get<1>(*this) = _VSTD::forward<_Up2>(__pair.second);
        -: 1258:        return *this;
        -: 1259:    }
        -: 1260:
        -: 1261:    // EXTENSION
        -: 1262:    template<class _Up, size_t _Np, class = __enable_if_t<
        -: 1263:        _And<
        -: 1264:            _BoolConstant<_Np == sizeof...(_Tp)>,
        -: 1265:            is_assignable<_Tp&, _Up const&>...
        -: 1266:        >::value
        -: 1267:    > >
        -: 1268:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1269:    tuple& operator=(array<_Up, _Np> const& __array)
        -: 1270:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up const&>...>::value))
        -: 1271:    {
        -: 1272:        _VSTD::__memberwise_copy_assign(*this, __array,
        -: 1273:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1274:        return *this;
        -: 1275:    }
        -: 1276:
        -: 1277:    // EXTENSION
        -: 1278:    template<class _Up, size_t _Np, class = void, class = __enable_if_t<
        -: 1279:        _And<
        -: 1280:            _BoolConstant<_Np == sizeof...(_Tp)>,
        -: 1281:            is_assignable<_Tp&, _Up>...
        -: 1282:        >::value
        -: 1283:    > >
        -: 1284:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1285:    tuple& operator=(array<_Up, _Np>&& __array)
        -: 1286:        _NOEXCEPT_((_And<is_nothrow_assignable<_Tp&, _Up>...>::value))
        -: 1287:    {
        -: 1288:        _VSTD::__memberwise_forward_assign(*this, _VSTD::move(__array),
        -: 1289:            __tuple_types<_If<true, _Up, _Tp>...>(),
        -: 1290:            typename __make_tuple_indices<sizeof...(_Tp)>::type());
        -: 1291:        return *this;
        -: 1292:    }
        -: 1293:
        -: 1294:    // [tuple.swap]
        -: 1295:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1296:    void swap(tuple& __t) _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        -: 1297:        {__base_.swap(__t.__base_);}
        -: 1298:
        -: 1299:#if _LIBCPP_STD_VER > 20
        -: 1300:    _LIBCPP_HIDE_FROM_ABI constexpr
        -: 1301:    void swap(const tuple& __t) const noexcept(__all<is_nothrow_swappable_v<const _Tp&>...>::value) {
        -: 1302:        __base_.swap(__t.__base_);
        -: 1303:    }
        -: 1304:#endif // _LIBCPP_STD_VER > 20
        -: 1305:};
        -: 1306:
        -: 1307:template <>
        -: 1308:class _LIBCPP_TEMPLATE_VIS tuple<>
        -: 1309:{
        -: 1310:public:
        -: 1311:    _LIBCPP_INLINE_VISIBILITY constexpr
        -: 1312:        tuple() _NOEXCEPT = default;
        -: 1313:    template <class _Alloc>
        -: 1314:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1315:        tuple(allocator_arg_t, const _Alloc&) _NOEXCEPT {}
        -: 1316:    template <class _Alloc>
        -: 1317:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1318:        tuple(allocator_arg_t, const _Alloc&, const tuple&) _NOEXCEPT {}
        -: 1319:    template <class _Up>
        -: 1320:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1321:        tuple(array<_Up, 0>) _NOEXCEPT {}
        -: 1322:    template <class _Alloc, class _Up>
        -: 1323:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1324:        tuple(allocator_arg_t, const _Alloc&, array<_Up, 0>) _NOEXCEPT {}
        -: 1325:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1326:    void swap(tuple&) _NOEXCEPT {}
        -: 1327:#if _LIBCPP_STD_VER > 20
        -: 1328:    _LIBCPP_HIDE_FROM_ABI constexpr void swap(const tuple&) const noexcept {}
        -: 1329:#endif
        -: 1330:};
        -: 1331:
        -: 1332:#if _LIBCPP_STD_VER > 20
        -: 1333:template <class... _TTypes, class... _UTypes, template<class> class _TQual, template<class> class _UQual>
        -: 1334:    requires requires { typename tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>; }
        -: 1335:struct basic_common_reference<tuple<_TTypes...>, tuple<_UTypes...>, _TQual, _UQual> {
        -: 1336:    using type = tuple<common_reference_t<_TQual<_TTypes>, _UQual<_UTypes>>...>;
        -: 1337:};
        -: 1338:
        -: 1339:template <class... _TTypes, class... _UTypes>
        -: 1340:    requires requires { typename tuple<common_type_t<_TTypes, _UTypes>...>; }
        -: 1341:struct common_type<tuple<_TTypes...>, tuple<_UTypes...>> {
        -: 1342:    using type = tuple<common_type_t<_TTypes, _UTypes>...>;
        -: 1343:};
        -: 1344:#endif // _LIBCPP_STD_VER > 20
        -: 1345:
        -: 1346:#if _LIBCPP_STD_VER > 14
        -: 1347:template <class ..._Tp>
        -: 1348:tuple(_Tp...) -> tuple<_Tp...>;
        -: 1349:template <class _Tp1, class _Tp2>
        -: 1350:tuple(pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
        -: 1351:template <class _Alloc, class ..._Tp>
        -: 1352:tuple(allocator_arg_t, _Alloc, _Tp...) -> tuple<_Tp...>;
        -: 1353:template <class _Alloc, class _Tp1, class _Tp2>
        -: 1354:tuple(allocator_arg_t, _Alloc, pair<_Tp1, _Tp2>) -> tuple<_Tp1, _Tp2>;
        -: 1355:template <class _Alloc, class ..._Tp>
        -: 1356:tuple(allocator_arg_t, _Alloc, tuple<_Tp...>) -> tuple<_Tp...>;
        -: 1357:#endif
        -: 1358:
        -: 1359:template <class ..._Tp>
        -: 1360:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1361:__enable_if_t<__all<__is_swappable<_Tp>::value...>::value, void>
        -: 1362:swap(tuple<_Tp...>& __t, tuple<_Tp...>& __u)
        -: 1363:                 _NOEXCEPT_(__all<__is_nothrow_swappable<_Tp>::value...>::value)
        -: 1364:    {__t.swap(__u);}
        -: 1365:
        -: 1366:#if _LIBCPP_STD_VER > 20
        -: 1367:template <class... _Tp>
        -: 1368:_LIBCPP_HIDE_FROM_ABI constexpr
        -: 1369:enable_if_t<__all<is_swappable_v<const _Tp>...>::value, void>
        -: 1370:swap(const tuple<_Tp...>& __lhs, const tuple<_Tp...>& __rhs)
        -: 1371:        noexcept(__all<is_nothrow_swappable_v<const _Tp>...>::value) {
        -: 1372:    __lhs.swap(__rhs);
        -: 1373:}
        -: 1374:#endif
        -: 1375:
        -: 1376:// get
        -: 1377:
        -: 1378:template <size_t _Ip, class ..._Tp>
        -: 1379:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1380:typename tuple_element<_Ip, tuple<_Tp...> >::type&
    #####: 1381:get(tuple<_Tp...>& __t) _NOEXCEPT
        -: 1382:{
        -: 1383:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    #####: 1384:    return static_cast<__tuple_leaf<_Ip, type>&>(__t.__base_).get();
        -: 1385:}
        -: 1386:
        -: 1387:template <size_t _Ip, class ..._Tp>
        -: 1388:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1389:const typename tuple_element<_Ip, tuple<_Tp...> >::type&
    #####: 1390:get(const tuple<_Tp...>& __t) _NOEXCEPT
        -: 1391:{
        -: 1392:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
    #####: 1393:    return static_cast<const __tuple_leaf<_Ip, type>&>(__t.__base_).get();
        -: 1394:}
        -: 1395:
        -: 1396:template <size_t _Ip, class ..._Tp>
        -: 1397:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1398:typename tuple_element<_Ip, tuple<_Tp...> >::type&&
        -: 1399:get(tuple<_Tp...>&& __t) _NOEXCEPT
        -: 1400:{
        -: 1401:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1402:    return static_cast<type&&>(
        -: 1403:             static_cast<__tuple_leaf<_Ip, type>&&>(__t.__base_).get());
        -: 1404:}
        -: 1405:
        -: 1406:template <size_t _Ip, class ..._Tp>
        -: 1407:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1408:const typename tuple_element<_Ip, tuple<_Tp...> >::type&&
        -: 1409:get(const tuple<_Tp...>&& __t) _NOEXCEPT
        -: 1410:{
        -: 1411:    typedef _LIBCPP_NODEBUG typename tuple_element<_Ip, tuple<_Tp...> >::type type;
        -: 1412:    return static_cast<const type&&>(
        -: 1413:             static_cast<const __tuple_leaf<_Ip, type>&&>(__t.__base_).get());
        -: 1414:}
        -: 1415:
        -: 1416:#if _LIBCPP_STD_VER > 11
        -: 1417:
        -: 1418:namespace __find_detail {
        -: 1419:
        -: 1420:static constexpr size_t __not_found = static_cast<size_t>(-1);
        -: 1421:static constexpr size_t __ambiguous = __not_found - 1;
        -: 1422:
        -: 1423:inline _LIBCPP_INLINE_VISIBILITY
        -: 1424:constexpr size_t __find_idx_return(size_t __curr_i, size_t __res, bool __matches) {
        -: 1425:    return !__matches ? __res :
        -: 1426:        (__res == __not_found ? __curr_i : __ambiguous);
        -: 1427:}
        -: 1428:
        -: 1429:template <size_t _Nx>
        -: 1430:inline _LIBCPP_INLINE_VISIBILITY
        -: 1431:constexpr size_t __find_idx(size_t __i, const bool (&__matches)[_Nx]) {
        -: 1432:  return __i == _Nx ? __not_found :
        -: 1433:      __find_detail::__find_idx_return(__i, __find_detail::__find_idx(__i + 1, __matches), __matches[__i]);
        -: 1434:}
        -: 1435:
        -: 1436:template <class _T1, class ..._Args>
        -: 1437:struct __find_exactly_one_checked {
        -: 1438:    static constexpr bool __matches[sizeof...(_Args)] = {is_same<_T1, _Args>::value...};
        -: 1439:    static constexpr size_t value = __find_detail::__find_idx(0, __matches);
        -: 1440:    static_assert(value != __not_found, "type not found in type list" );
        -: 1441:    static_assert(value != __ambiguous, "type occurs more than once in type list");
        -: 1442:};
        -: 1443:
        -: 1444:template <class _T1>
        -: 1445:struct __find_exactly_one_checked<_T1> {
        -: 1446:    static_assert(!is_same<_T1, _T1>::value, "type not in empty type list");
        -: 1447:};
        -: 1448:
        -: 1449:} // namespace __find_detail
        -: 1450:
        -: 1451:template <typename _T1, typename... _Args>
        -: 1452:struct __find_exactly_one_t
        -: 1453:    : public __find_detail::__find_exactly_one_checked<_T1, _Args...> {
        -: 1454:};
        -: 1455:
        -: 1456:template <class _T1, class... _Args>
        -: 1457:inline _LIBCPP_INLINE_VISIBILITY
        -: 1458:constexpr _T1& get(tuple<_Args...>& __tup) noexcept
        -: 1459:{
        -: 1460:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
        -: 1461:}
        -: 1462:
        -: 1463:template <class _T1, class... _Args>
        -: 1464:inline _LIBCPP_INLINE_VISIBILITY
        -: 1465:constexpr _T1 const& get(tuple<_Args...> const& __tup) noexcept
        -: 1466:{
        -: 1467:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(__tup);
        -: 1468:}
        -: 1469:
        -: 1470:template <class _T1, class... _Args>
        -: 1471:inline _LIBCPP_INLINE_VISIBILITY
        -: 1472:constexpr _T1&& get(tuple<_Args...>&& __tup) noexcept
        -: 1473:{
        -: 1474:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));
        -: 1475:}
        -: 1476:
        -: 1477:template <class _T1, class... _Args>
        -: 1478:inline _LIBCPP_INLINE_VISIBILITY
        -: 1479:constexpr _T1 const&& get(tuple<_Args...> const&& __tup) noexcept
        -: 1480:{
        -: 1481:    return _VSTD::get<__find_exactly_one_t<_T1, _Args...>::value>(_VSTD::move(__tup));
        -: 1482:}
        -: 1483:
        -: 1484:#endif
        -: 1485:
        -: 1486:// tie
        -: 1487:
        -: 1488:template <class ..._Tp>
        -: 1489:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1490:tuple<_Tp&...>
        -: 1491:tie(_Tp&... __t) _NOEXCEPT
        -: 1492:{
        -: 1493:    return tuple<_Tp&...>(__t...);
        -: 1494:}
        -: 1495:
        -: 1496:template <class _Up>
        -: 1497:struct __ignore_t
        -: 1498:{
        -: 1499:    template <class _Tp>
        -: 1500:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1501:    const __ignore_t& operator=(_Tp&&) const {return *this;}
        -: 1502:};
        -: 1503:
        -: 1504:namespace {
        -: 1505:  constexpr __ignore_t<unsigned char> ignore = __ignore_t<unsigned char>();
        -: 1506:} // namespace
        -: 1507:
        -: 1508:template <class... _Tp>
        -: 1509:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1510:tuple<typename __unwrap_ref_decay<_Tp>::type...>
    #####: 1511:make_tuple(_Tp&&... __t)
        -: 1512:{
    #####: 1513:    return tuple<typename __unwrap_ref_decay<_Tp>::type...>(_VSTD::forward<_Tp>(__t)...);
        -: 1514:}
        -: 1515:
        -: 1516:template <class... _Tp>
        -: 1517:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1518:tuple<_Tp&&...>
        -: 1519:forward_as_tuple(_Tp&&... __t) _NOEXCEPT
        -: 1520:{
        -: 1521:    return tuple<_Tp&&...>(_VSTD::forward<_Tp>(__t)...);
        -: 1522:}
        -: 1523:
        -: 1524:template <size_t _Ip>
        -: 1525:struct __tuple_equal
        -: 1526:{
        -: 1527:    template <class _Tp, class _Up>
        -: 1528:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1529:    bool operator()(const _Tp& __x, const _Up& __y)
        -: 1530:    {
        -: 1531:        return __tuple_equal<_Ip - 1>()(__x, __y) && _VSTD::get<_Ip-1>(__x) == _VSTD::get<_Ip-1>(__y);
        -: 1532:    }
        -: 1533:};
        -: 1534:
        -: 1535:template <>
        -: 1536:struct __tuple_equal<0>
        -: 1537:{
        -: 1538:    template <class _Tp, class _Up>
        -: 1539:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1540:    bool operator()(const _Tp&, const _Up&)
        -: 1541:    {
        -: 1542:        return true;
        -: 1543:    }
        -: 1544:};
        -: 1545:
        -: 1546:template <class ..._Tp, class ..._Up>
        -: 1547:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1548:bool
        -: 1549:operator==(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1550:{
        -: 1551:    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
        -: 1552:    return __tuple_equal<sizeof...(_Tp)>()(__x, __y);
        -: 1553:}
        -: 1554:
        -: 1555:#if _LIBCPP_STD_VER > 17
        -: 1556:
        -: 1557:// operator<=>
        -: 1558:
        -: 1559:template <class ..._Tp, class ..._Up, size_t ..._Is>
        -: 1560:_LIBCPP_HIDE_FROM_ABI constexpr
        -: 1561:auto
        -: 1562:__tuple_compare_three_way(const tuple<_Tp...>& __x, const tuple<_Up...>& __y, index_sequence<_Is...>) {
        -: 1563:    common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...> __result = strong_ordering::equal;
        -: 1564:    static_cast<void>(((__result = _VSTD::__synth_three_way(_VSTD::get<_Is>(__x), _VSTD::get<_Is>(__y)), __result != 0) || ...));
        -: 1565:    return __result;
        -: 1566:}
        -: 1567:
        -: 1568:template <class ..._Tp, class ..._Up>
        -: 1569:requires (sizeof...(_Tp) == sizeof...(_Up))
        -: 1570:_LIBCPP_HIDE_FROM_ABI constexpr
        -: 1571:common_comparison_category_t<__synth_three_way_result<_Tp, _Up>...>
        -: 1572:operator<=>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1573:{
        -: 1574:    return _VSTD::__tuple_compare_three_way(__x, __y, index_sequence_for<_Tp...>{});
        -: 1575:}
        -: 1576:
        -: 1577:#else // _LIBCPP_STD_VER > 17
        -: 1578:
        -: 1579:template <class ..._Tp, class ..._Up>
        -: 1580:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1581:bool
        -: 1582:operator!=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1583:{
        -: 1584:    return !(__x == __y);
        -: 1585:}
        -: 1586:
        -: 1587:template <size_t _Ip>
        -: 1588:struct __tuple_less
        -: 1589:{
        -: 1590:    template <class _Tp, class _Up>
        -: 1591:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1592:    bool operator()(const _Tp& __x, const _Up& __y)
        -: 1593:    {
        -: 1594:        const size_t __idx = tuple_size<_Tp>::value - _Ip;
        -: 1595:        if (_VSTD::get<__idx>(__x) < _VSTD::get<__idx>(__y))
        -: 1596:            return true;
        -: 1597:        if (_VSTD::get<__idx>(__y) < _VSTD::get<__idx>(__x))
        -: 1598:            return false;
        -: 1599:        return __tuple_less<_Ip-1>()(__x, __y);
        -: 1600:    }
        -: 1601:};
        -: 1602:
        -: 1603:template <>
        -: 1604:struct __tuple_less<0>
        -: 1605:{
        -: 1606:    template <class _Tp, class _Up>
        -: 1607:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1608:    bool operator()(const _Tp&, const _Up&)
        -: 1609:    {
        -: 1610:        return false;
        -: 1611:    }
        -: 1612:};
        -: 1613:
        -: 1614:template <class ..._Tp, class ..._Up>
        -: 1615:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1616:bool
        -: 1617:operator<(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1618:{
        -: 1619:    static_assert (sizeof...(_Tp) == sizeof...(_Up), "Can't compare tuples of different sizes");
        -: 1620:    return __tuple_less<sizeof...(_Tp)>()(__x, __y);
        -: 1621:}
        -: 1622:
        -: 1623:template <class ..._Tp, class ..._Up>
        -: 1624:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1625:bool
        -: 1626:operator>(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1627:{
        -: 1628:    return __y < __x;
        -: 1629:}
        -: 1630:
        -: 1631:template <class ..._Tp, class ..._Up>
        -: 1632:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1633:bool
        -: 1634:operator>=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1635:{
        -: 1636:    return !(__x < __y);
        -: 1637:}
        -: 1638:
        -: 1639:template <class ..._Tp, class ..._Up>
        -: 1640:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1641:bool
        -: 1642:operator<=(const tuple<_Tp...>& __x, const tuple<_Up...>& __y)
        -: 1643:{
        -: 1644:    return !(__y < __x);
        -: 1645:}
        -: 1646:
        -: 1647:#endif // _LIBCPP_STD_VER > 17
        -: 1648:
        -: 1649:// tuple_cat
        -: 1650:
        -: 1651:template <class _Tp, class _Up> struct __tuple_cat_type;
        -: 1652:
        -: 1653:template <class ..._Ttypes, class ..._Utypes>
        -: 1654:struct __tuple_cat_type<tuple<_Ttypes...>, __tuple_types<_Utypes...> >
        -: 1655:{
        -: 1656:    typedef _LIBCPP_NODEBUG tuple<_Ttypes..., _Utypes...> type;
        -: 1657:};
        -: 1658:
        -: 1659:template <class _ResultTuple, bool _Is_Tuple0TupleLike, class ..._Tuples>
        -: 1660:struct __tuple_cat_return_1
        -: 1661:{
        -: 1662:};
        -: 1663:
        -: 1664:template <class ..._Types, class _Tuple0>
        -: 1665:struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0>
        -: 1666:{
        -: 1667:  using type _LIBCPP_NODEBUG = typename __tuple_cat_type<
        -: 1668:      tuple<_Types...>,
        -: 1669:      typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
        -: 1670:    >::type;
        -: 1671:};
        -: 1672:
        -: 1673:template <class ..._Types, class _Tuple0, class _Tuple1, class ..._Tuples>
        -: 1674:struct __tuple_cat_return_1<tuple<_Types...>, true, _Tuple0, _Tuple1, _Tuples...>
        -: 1675:    : public __tuple_cat_return_1<
        -: 1676:                 typename __tuple_cat_type<
        -: 1677:                     tuple<_Types...>,
        -: 1678:                     typename __make_tuple_types<__remove_cvref_t<_Tuple0> >::type
        -: 1679:                 >::type,
        -: 1680:                 __tuple_like_ext<__libcpp_remove_reference_t<_Tuple1> >::value,
        -: 1681:                 _Tuple1, _Tuples...>
        -: 1682:{
        -: 1683:};
        -: 1684:
        -: 1685:template <class ..._Tuples> struct __tuple_cat_return;
        -: 1686:
        -: 1687:template <class _Tuple0, class ..._Tuples>
        -: 1688:struct __tuple_cat_return<_Tuple0, _Tuples...>
        -: 1689:    : public __tuple_cat_return_1<tuple<>,
        -: 1690:         __tuple_like_ext<__libcpp_remove_reference_t<_Tuple0> >::value, _Tuple0,
        -: 1691:                                                                     _Tuples...>
        -: 1692:{
        -: 1693:};
        -: 1694:
        -: 1695:template <>
        -: 1696:struct __tuple_cat_return<>
        -: 1697:{
        -: 1698:    typedef _LIBCPP_NODEBUG tuple<> type;
        -: 1699:};
        -: 1700:
        -: 1701:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1702:tuple<>
        -: 1703:tuple_cat()
        -: 1704:{
        -: 1705:    return tuple<>();
        -: 1706:}
        -: 1707:
        -: 1708:template <class _Rp, class _Indices, class _Tuple0, class ..._Tuples>
        -: 1709:struct __tuple_cat_return_ref_imp;
        -: 1710:
        -: 1711:template <class ..._Types, size_t ..._I0, class _Tuple0>
        -: 1712:struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>, _Tuple0>
        -: 1713:{
        -: 1714:    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1715:    typedef tuple<_Types..., typename __apply_cv<_Tuple0,
        -: 1716:                          typename tuple_element<_I0, _T0>::type>::type&&...> type;
        -: 1717:};
        -: 1718:
        -: 1719:template <class ..._Types, size_t ..._I0, class _Tuple0, class _Tuple1, class ..._Tuples>
        -: 1720:struct __tuple_cat_return_ref_imp<tuple<_Types...>, __tuple_indices<_I0...>,
        -: 1721:                                  _Tuple0, _Tuple1, _Tuples...>
        -: 1722:    : public __tuple_cat_return_ref_imp<
        -: 1723:         tuple<_Types..., typename __apply_cv<_Tuple0,
        -: 1724:               typename tuple_element<_I0,
        -: 1725:                  __libcpp_remove_reference_t<_Tuple0> >::type>::type&&...>,
        -: 1726:         typename __make_tuple_indices<tuple_size<__libcpp_remove_reference_t<_Tuple1> >::value>::type,
        -: 1727:         _Tuple1, _Tuples...>
        -: 1728:{
        -: 1729:};
        -: 1730:
        -: 1731:template <class _Tuple0, class ..._Tuples>
        -: 1732:struct __tuple_cat_return_ref
        -: 1733:    : public __tuple_cat_return_ref_imp<tuple<>,
        -: 1734:               typename __make_tuple_indices<
        -: 1735:                        tuple_size<__libcpp_remove_reference_t<_Tuple0> >::value
        -: 1736:               >::type, _Tuple0, _Tuples...>
        -: 1737:{
        -: 1738:};
        -: 1739:
        -: 1740:template <class _Types, class _I0, class _J0>
        -: 1741:struct __tuple_cat;
        -: 1742:
        -: 1743:template <class ..._Types, size_t ..._I0, size_t ..._J0>
        -: 1744:struct __tuple_cat<tuple<_Types...>, __tuple_indices<_I0...>, __tuple_indices<_J0...> >
        -: 1745:{
        -: 1746:    template <class _Tuple0>
        -: 1747:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1748:    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&>::type
        -: 1749:    operator()(tuple<_Types...> __t, _Tuple0&& __t0)
        -: 1750:    {
        -: 1751:        (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
        -: 1752:        return _VSTD::forward_as_tuple(
        -: 1753:            _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,
        -: 1754:            _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...);
        -: 1755:    }
        -: 1756:
        -: 1757:    template <class _Tuple0, class _Tuple1, class ..._Tuples>
        -: 1758:    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1759:    typename __tuple_cat_return_ref<tuple<_Types...>&&, _Tuple0&&, _Tuple1&&, _Tuples&&...>::type
        -: 1760:    operator()(tuple<_Types...> __t, _Tuple0&& __t0, _Tuple1&& __t1, _Tuples&& ...__tpls)
        -: 1761:    {
        -: 1762:        (void)__t; // avoid unused parameter warning on GCC when _I0 is empty
        -: 1763:        typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1764:        typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple1> _T1;
        -: 1765:        return __tuple_cat<
        -: 1766:            tuple<_Types...,
        -: 1767:                  typename __apply_cv<_Tuple0, typename tuple_element<
        -: 1768:                                                   _J0, _T0>::type>::type&&...>,
        -: 1769:            typename __make_tuple_indices<sizeof...(_Types) +
        -: 1770:                                          tuple_size<_T0>::value>::type,
        -: 1771:            typename __make_tuple_indices<tuple_size<_T1>::value>::type>()(
        -: 1772:            _VSTD::forward_as_tuple(
        -: 1773:                _VSTD::forward<_Types>(_VSTD::get<_I0>(__t))...,
        -: 1774:                _VSTD::get<_J0>(_VSTD::forward<_Tuple0>(__t0))...),
        -: 1775:            _VSTD::forward<_Tuple1>(__t1), _VSTD::forward<_Tuples>(__tpls)...);
        -: 1776:    }
        -: 1777:};
        -: 1778:
        -: 1779:template <class _Tuple0, class... _Tuples>
        -: 1780:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX14
        -: 1781:typename __tuple_cat_return<_Tuple0, _Tuples...>::type
        -: 1782:tuple_cat(_Tuple0&& __t0, _Tuples&&... __tpls)
        -: 1783:{
        -: 1784:    typedef _LIBCPP_NODEBUG __libcpp_remove_reference_t<_Tuple0> _T0;
        -: 1785:    return __tuple_cat<tuple<>, __tuple_indices<>,
        -: 1786:                  typename __make_tuple_indices<tuple_size<_T0>::value>::type>()
        -: 1787:                  (tuple<>(), _VSTD::forward<_Tuple0>(__t0),
        -: 1788:                                            _VSTD::forward<_Tuples>(__tpls)...);
        -: 1789:}
        -: 1790:
        -: 1791:template <class ..._Tp, class _Alloc>
        -: 1792:struct _LIBCPP_TEMPLATE_VIS uses_allocator<tuple<_Tp...>, _Alloc>
        -: 1793:    : true_type {};
        -: 1794:
        -: 1795:template <class _T1, class _T2>
        -: 1796:template <class... _Args1, class... _Args2, size_t ..._I1, size_t ..._I2>
        -: 1797:inline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_SINCE_CXX20
        -: 1798:pair<_T1, _T2>::pair(piecewise_construct_t,
        -: 1799:                     tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,
        -: 1800:                     __tuple_indices<_I1...>, __tuple_indices<_I2...>)
        -: 1801:    :  first(_VSTD::forward<_Args1>(_VSTD::get<_I1>( __first_args))...),
        -: 1802:      second(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)
        -: 1803:{
        -: 1804:}
        -: 1805:
        -: 1806:#if _LIBCPP_STD_VER > 14
        -: 1807:template <class _Tp>
        -: 1808:inline constexpr size_t tuple_size_v = tuple_size<_Tp>::value;
        -: 1809:
        -: 1810:#define _LIBCPP_NOEXCEPT_RETURN(...) noexcept(noexcept(__VA_ARGS__)) { return __VA_ARGS__; }
        -: 1811:
        -: 1812:template <class _Fn, class _Tuple, size_t ..._Id>
        -: 1813:inline _LIBCPP_INLINE_VISIBILITY
        -: 1814:constexpr decltype(auto) __apply_tuple_impl(_Fn && __f, _Tuple && __t,
        -: 1815:                                            __tuple_indices<_Id...>)
        -: 1816:_LIBCPP_NOEXCEPT_RETURN(
        -: 1817:    _VSTD::__invoke(
        -: 1818:        _VSTD::forward<_Fn>(__f),
        -: 1819:        _VSTD::get<_Id>(_VSTD::forward<_Tuple>(__t))...)
        -: 1820:)
        -: 1821:
        -: 1822:template <class _Fn, class _Tuple>
        -: 1823:inline _LIBCPP_INLINE_VISIBILITY
        -: 1824:constexpr decltype(auto) apply(_Fn && __f, _Tuple && __t)
        -: 1825:_LIBCPP_NOEXCEPT_RETURN(
        -: 1826:    _VSTD::__apply_tuple_impl(
        -: 1827:        _VSTD::forward<_Fn>(__f), _VSTD::forward<_Tuple>(__t),
        -: 1828:        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{})
        -: 1829:)
        -: 1830:
        -: 1831:template <class _Tp, class _Tuple, size_t... _Idx>
        -: 1832:inline _LIBCPP_INLINE_VISIBILITY
        -: 1833:constexpr _Tp __make_from_tuple_impl(_Tuple&& __t, __tuple_indices<_Idx...>)
        -: 1834:_LIBCPP_NOEXCEPT_RETURN(
        -: 1835:    _Tp(_VSTD::get<_Idx>(_VSTD::forward<_Tuple>(__t))...)
        -: 1836:)
        -: 1837:
        -: 1838:template <class _Tp, class _Tuple>
        -: 1839:inline _LIBCPP_INLINE_VISIBILITY
        -: 1840:constexpr _Tp make_from_tuple(_Tuple&& __t)
        -: 1841:_LIBCPP_NOEXCEPT_RETURN(
        -: 1842:    _VSTD::__make_from_tuple_impl<_Tp>(_VSTD::forward<_Tuple>(__t),
        -: 1843:        typename __make_tuple_indices<tuple_size_v<remove_reference_t<_Tuple>>>::type{})
        -: 1844:)
        -: 1845:
        -: 1846:#undef _LIBCPP_NOEXCEPT_RETURN
        -: 1847:
        -: 1848:#endif // _LIBCPP_STD_VER > 14
        -: 1849:
        -: 1850:#endif // !defined(_LIBCPP_CXX03_LANG)
        -: 1851:
        -: 1852:_LIBCPP_END_NAMESPACE_STD
        -: 1853:
        -: 1854:#if !defined(_LIBCPP_REMOVE_TRANSITIVE_INCLUDES) && _LIBCPP_STD_VER <= 20
        -: 1855:#  include <exception>
        -: 1856:#  include <iosfwd>
        -: 1857:#  include <new>
        -: 1858:#  include <type_traits>
        -: 1859:#  include <typeinfo>
        -: 1860:#  include <utility>
        -: 1861:#endif
        -: 1862:
        -: 1863:#endif // _LIBCPP_TUPLE
