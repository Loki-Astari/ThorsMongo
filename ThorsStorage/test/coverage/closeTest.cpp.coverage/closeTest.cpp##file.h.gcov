        -:    0:Source:../file.h
        -:    0:Graph:coverage/closeTest.gcno
        -:    0:Data:coverage/closeTest.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#ifndef THORSANVIL_FILESYSTEM_COLUMNFORMAT_FILE_H
        -:    2:#define THORSANVIL_FILESYSTEM_COLUMNFORMAT_FILE_H
        -:    3:
        -:    4:#include "filesystem.h"
        -:    5:#include <ThorSerialize/Traits.h>
        -:    6:#include <string>
        -:    7:#include <tuple>
        -:    8:
        -:    9:// See: https://codereview.stackexchange.com/questions/81922/macro-to-build-type-declaration
        -:   10:// For details about the Traits type and how it is built.
        -:   11:
        -:   12:namespace ThorsAnvil
        -:   13:{
        -:   14:    namespace FileSystem
        -:   15:    {
        -:   16:        namespace ColumnFormat
        -:   17:        {
        -:   18:    /*
        -:   19:     * This header defines two main types.
        -:   20:     * FileBase and FileMembers
        -:   21:     *
        -:   22:     * The FileMembers class holds a tuple of all subfiles and mainly deals with distributing any call on the class to all submembers.
        -:   23:     * Just to prove all rules have exceptions, the FileMembers class also holds a state member that is the binary or of all the other
        -:   24:     * subfiles state flags. This makes checking the overall state of the object simler.
        -:   25:     *
        -:   26:     * The FileBase class acts as the logical File object.
        -:   27:     * It contains any buisness logic associated with a file (including its primary name).
        -:   28:     *
        -:   29:     * The user variants of FileBase are:
        -:   30:     *      IFile:      Input File
        -:   31:     *      OFile:      Output File
        -:   32:     *      File:       Can be either in or out or in/out just need to be specific in the open flag.
        -:   33:     */
        -:   34:     
        -:   35:    // Need to forward declare FileMembers as it is used in the Implementation details section.
        -:   36:    template<typename S, typename T>
        -:   37:    class FileMembers;
        -:   38:
        -:   39:    namespace Impl
        -:   40:    {
        -:   41:        /*
        -:   42:         * This section contains some utility class to help in building types (there is no code here)
        -:   43:         * NamingConvention:
        -:   44:         *      XXXSelector:    A class partial specialization that helps select a type for XXX based on input type T.
        -:   45:         *      XXXBuilder:     A class partial specialization that builds a tuple type XXX based on input type Arg...
        -:   46:         *
        -:   47:         * Normally Selector and builder are used together to build a tuple of types.
        -:   48:         *
        -:   49:         * GetPointerMember:    Given a pointer to a member (Type). Returns the value being pointed at.
        -:   50:         * FileType:            Given a type T The type of file we will use to store it.
        -:   51:         *                      A: If T is a POD type this is type S (which will be one std::ifstream, std::ofstream, std::fstream)
        -:   52:         *                      B: If T is a std::string this type is a struct with S being used to hold data and std::fstream used to hold an index into the strings.
        -:   53:         *                         This is so given a position we can quickly seek to a position in the file where the string is held.
        -:   54:         *                      C: If T is an object mapped by ThorsAnvil_MakeTrait (see ThorsSerializer) then File<S, T>.
        -:   55:         *                         Thus we map a structure to multiple files one file for each members. If a member is another structure
        -:   56:         *                         this becomes a subdirectory with each of its memebrs mapped to a file in this subdirectory.
        -:   57:         * TupleFileType:       Given a class T; This becomes a std::tuple<FileType...> one member of the tuple for each member of the class.
        -:   58:         *
        -:   59:         * PreOpenState:        When opening a file we do a pre-scan to decide if any file will fail to open.
        -:   60:         *                      We track the state of how we are doing with this type so we can tidy up if we decide the open will fail.
        -:   61:         * OpenState:           Given a type T the type is used to store state for an attempted opening.
        -:   62:         *                      A: If T is POD or std::string then PreOpenState
        -:   63:         *                      B: If T is an object mapped by ThorsAnvil_MakeTrait (see ThorsSerializer) then std::tuple<OpenState...>
        -:   64:         * OpenStateTuple:      Given a class T; this becomes a std::tuple<OpenState...> one member of the tuple for each member of the class.
        -:   65:         * OpenMemberTuple:     A Utility to help.
        -:   66:         */
        -:   67:
        -:   68:        // Get the type being pointed at by a pointer to member variable.
        -:   69:        template<typename P>
        -:   70:        struct GetPointerMember;
        -:   71:
        -:   72:        template<typename R, typename T>
        -:   73:        struct GetPointerMember<std::pair<char const*, R T::*>>
        -:   74:        {
        -:   75:            using ReturnType = R;
        -:   76:        };
        -:   77:
        -:   78:        template<typename P>
        -:   79:        using GetPointerMemberType = typename GetPointerMember<P>::ReturnType;
        -:   80:
        -:   81:        /*
        -:   82:         * FileTypeSelector:    Use template specialization to define the stream class used.
        -:   83:         *                      For basic objects this is `std::fstream`
        -:   84:         *                      For Json::Map types use a FileMembers<S, T> types as this will recursively contain
        -:   85:         *                      File<M> or `std::fstream` types.
        -:   86:         */
        -:   87:        template<typename S, typename T, ThorsAnvil::Serialize::TraitType type = ThorsAnvil::Serialize::Traits<T>::type>
        -:   88:        struct FileTypeSelector;
        -:   89:
        -:   90:        template<typename S, typename T>
        -:   91:        struct FileTypeSelector<S, T, ThorsAnvil::Serialize::TraitType::Value>
        -:   92:        {
        -:   93:            using FileType  = S;
        -:   94:        };
        -:   95:
        -:   96:        template<typename S>
        -:   97:        struct FileTypeSelector<S, std::string, ThorsAnvil::Serialize::TraitType::Value>
        -:   98:        {
      148:   99:            using FileType  = struct FileTypeStruct
        -:  100:            {
        -:  101:                S               data;
        -:  102:                std::fstream    index;
        -:  103:            };
        -:  104:        };
        -:  105:
        -:  106:        template<typename S, typename T>
        -:  107:        struct FileTypeSelector<S, T, ThorsAnvil::Serialize::TraitType::Map>
        -:  108:        {
        -:  109:            using FileType  = FileMembers<S, T>;
        -:  110:        };
        -:  111:
        -:  112:        template<typename S, typename T>
        -:  113:        using FileType = typename FileTypeSelector<S, T>::FileType;
        -:  114:
        -:  115:        /*
        -:  116:         * FileTupleBuilder:    Iterate over a tuple to get the stream types.
        -:  117:         */
        -:  118:        template<typename S, typename T, typename TUP = typename ThorsAnvil::Serialize::Traits<T>::Members>
        -:  119:        struct TupleFileTypeBuilder;
        -:  120:
        -:  121:        template<typename S, typename T, typename... Args>
        -:  122:        struct TupleFileTypeBuilder<S, T, std::tuple<Args...>>
        -:  123:        {
        -:  124:            using TupleFileType = std::tuple<FileType<S, GetPointerMemberType<Args>>...>;
        -:  125:        };
        -:  126:
        -:  127:        template<typename S, typename T>
        -:  128:        using TupleFileType = typename TupleFileTypeBuilder<S, T>::TupleFileType;
        -:  129:
        -:  130:        /*
        -:  131:         * OpenStateSelector:   Select if we use PreOpenState (for std::fstream) or a struct (for FileMembers)
        -:  132:         */
        -:  133:        enum PreOpenState {NoAction, NoDir, DirExists};
        -:  134:
        -:  135:        template<typename T, ThorsAnvil::Serialize::TraitType type = ThorsAnvil::Serialize::Traits<T>::type>
        -:  136:        struct OpenStateSelector;
        -:  137:
        -:  138:        /*
        -:  139:         * OpenStateBuilder:   Build a tuple of (OpenStateSelector) for the underlying stream types.
        -:  140:         */
        -:  141:        template<typename T>
        -:  142:        struct OpenStateTupleBuilder;
        -:  143:
        -:  144:        template<typename... Args>
        -:  145:        struct OpenStateTupleBuilder<std::tuple<Args...>>
        -:  146:        {
        -:  147:            using OpenStateTuple = std::tuple<typename OpenStateSelector<GetPointerMemberType<Args>>::OpenState...>;
        -:  148:        };
        -:  149:
        -:  150:        template<typename T>
        -:  151:        using OpenStateTuple = typename OpenStateTupleBuilder<T>::OpenStateTuple;
        -:  152:
        -:  153:        template<typename T>
        -:  154:        struct OpenStateSelector<T, ThorsAnvil::Serialize::TraitType::Value>
        -:  155:        {
        -:  156:            using OpenState = PreOpenState;
        -:  157:        };
        -:  158:
        -:  159:        template<typename T>
        -:  160:        struct OpenStateSelector<T, ThorsAnvil::Serialize::TraitType::Map>
        -:  161:        {
        -:  162:            struct OpenState
        -:  163:            {
        -:  164:                using OpenMemberTuple = OpenStateTuple<typename ThorsAnvil::Serialize::Traits<T>::Members>;
        -:  165:                PreOpenState        base;
        -:  166:                OpenMemberTuple     members;
        -:  167:            };
        -:  168:        };
        -:  169:
        -:  170:        /*
        -:  171:         * The types used after we have built it from the above
        -:  172:         */
        -:  173:        template<typename T>
        -:  174:        using OpenState      = typename OpenStateSelector<T>::OpenState;
        -:  175:        template<typename T>
        -:  176:        using OpenMemberTuple = typename OpenState<T>::OpenMemberTuple;
        -:  177:
        -:  178:        // Forward declaration of FileAccessObjectType See file.tpp for details.
        -:  179:        template<typename F, typename T, ThorsAnvil::Serialize::TraitType type = ThorsAnvil::Serialize::Traits<T>::type>
        -:  180:        struct FileAccessObjectType;
        -:  181:    }
        -:  182:
        -:  183:    using streampos = unsigned long;
        -:  184:    using streamoff = signed long;
        -:  185:    using seekdir   = std::ios_base::seekdir;
        -:  186:
        -:  187:    template<typename S, typename T>
        -:  188:    class FileMembers
        -:  189:    {
        -:  190:        using Traits    = ThorsAnvil::Serialize::Traits<T>;
        -:  191:        using Members   = typename Traits::Members;
        -:  192:        using Index     = std::make_index_sequence<std::tuple_size<Members>::value>;
        -:  193:
        -:  194:        using FileTuple = Impl::TupleFileType<S, T>;
        -:  195:
        -:  196:        FileTuple       fileTuple;
        -:  197:        iostate         state;
        -:  198:
        -:  199:        public:
        -:  200:             FileMembers();
        -:  201:
        -:  202:            Impl::OpenState<T> doOpenTry(bool& ok, std::string const& path, openmode mode);
        -:  203:            void doOpenFin(bool ok, std::string const& path, openmode mode, Impl::OpenState<T> const& state);
        9:  204:            void close()                            {doCloseMembers(Index{});}
        -:  205:            void read(T& data)                      {readMembers(data, Index{});}
        -:  206:            void write(T const& data)               {writeMembers(data, Index{});}
       54:  207:            void setstate(iostate extraState)       {setstateLocalOnly(extraState); setstateMembers(extraState, Index{});}
      216:  208:            void clear(iostate newState = goodbit)  {clearLocalOnly(newState);      clearMembers(newState, Index{});}
        -:  209:            void seekg(streampos pos)               {seekgMembers(pos, Index{});}
        -:  210:            void seekp(streampos pos)               {seekpMembers(pos, Index{});}
        -:  211:
        -:  212:            // https://en.cppreference.com/w/cpp/io/ios_base/iostate
        -:  213:            bool good()                             const   {return !(state & (eofbit | badbit | failbit));}
        -:  214:            bool eof()                              const   {return state & eofbit;}
        -:  215:            bool bad()                              const   {return state & badbit;}
      136:  216:            bool fail()                             const   {return state & (failbit | badbit);}
      136:  217:            operator bool()                         const   {return !fail();}
       46:  218:            bool operator!()                        const   {return !static_cast<bool>(*this);}
      560:  219:            iostate rdstate()                       const   {return state;}
        -:  220:        private:
        -:  221:            template<std::size_t... I>
        -:  222:            Impl::OpenMemberTuple<T> doOpenTryMembers(bool& ok, std::string const& path, openmode mode, std::index_sequence<I...>);
        -:  223:            template<std::size_t... I>
        -:  224:            void doOpenFinMembers(bool ok, std::string const& path, openmode mode, Impl::OpenMemberTuple<T> const& state, std::index_sequence<I...>);
        -:  225:
        -:  226:            template<std::size_t... I>
        -:  227:            void doCloseMembers(std::index_sequence<I...>);
        -:  228:
        -:  229:            template<std::size_t... I>
        -:  230:            void readMembers(T& data, std::index_sequence<I...>);
        -:  231:
        -:  232:            template<std::size_t... I>
        -:  233:            void writeMembers(T const& data, std::index_sequence<I...>);
        -:  234:
        -:  235:            template<std::size_t... I>
        -:  236:            void setstateMembers(iostate extraState, std::index_sequence<I...>);
        -:  237:
        -:  238:            template<std::size_t... I>
        -:  239:            void clearMembers(iostate newState, std::index_sequence<I...>);
        -:  240:
        -:  241:            template<std::size_t... I>
        -:  242:            void seekgMembers(streampos pos, std::index_sequence<I...>);
        -:  243:
        -:  244:            template<std::size_t... I>
        -:  245:            void seekpMembers(streampos pos, std::index_sequence<I...>);
        -:  246:
        -:  247:            template<std::size_t I>
        -:  248:            std::string getMemberFilePath(std::string const& path);
        -:  249:
        -:  250:        protected:
     1697:  251:            void setstateLocalOnly(iostate extraState)      {state |= extraState;}
      216:  252:            void clearLocalOnly(iostate newState)           {state = newState;}
        -:  253:    };
        -:  254:
        -:  255:    template<typename S, typename T>
        -:  256:    class FileBase: public FileMembers<S, T>
        -:  257:    {
        -:  258:        bool            fileOpened;
        -:  259:        std::string     baseFileName;
        -:  260:        std::fstream    index;
        -:  261:        streampos       getPos;
        -:  262:        streampos       putPos;
        -:  263:
        -:  264:        public:
        -:  265:            FileBase(std::string fileName = "", openmode mode = 0);
        -:  266:
        -:  267:            void open(std::string fileName, openmode mode = 0);
        -:  268:            void close();
        -:  269:
        -:  270:            void read(T& data);
        -:  271:            void write(T const& data);
        -:  272:
        -:  273:            streampos   tellg() {return getPos;}
        -:  274:            streampos   tellp() {return putPos;}
        -:  275:            void        seekg(streampos pos);
        -:  276:            void        seekp(streampos pos);
        -:  277:            void        seekg(streamoff off, seekdir dir);
        -:  278:            void        seekp(streamoff off, seekdir dir);
        -:  279:
        -:  280:            friend FileBase& operator>>(FileBase& file, T& data)
        -:  281:            {
        -:  282:                file.read(data);
        -:  283:                return file;
        -:  284:            }
        -:  285:            friend FileBase& operator<<(FileBase& file, T const& data)
        -:  286:            {
        -:  287:                file.write(data);
        -:  288:                return file;
        -:  289:            }
        -:  290:        private:
        -:  291:            void open(openmode mode);
        -:  292:    };
        -:  293:
        -:  294:    template<typename T>
        -:  295:    class IFile: public FileBase<std::ifstream, T>
        -:  296:    {
        -:  297:        public:
       48:  298:            IFile(std::string fileName = "", openmode mode = std::ios::in)
       24:  299:                : FileBase<std::ifstream, T>(std::forward<std::string>(fileName), mode)
       48:  300:            {}
        -:  301:            void open(std::string fileName, openmode mode = std::ios::in)
        -:  302:            {
        -:  303:                return FileBase<std::ifstream, T>::open(std::forward<std::string>(fileName), mode);
        -:  304:            }
        -:  305:    };
        -:  306:    template<typename T>
        -:  307:    class OFile: public FileBase<std::ofstream, T>
        -:  308:    {
        -:  309:        public:
       74:  310:            OFile(std::string fileName = "", openmode mode = std::ios::out)
       37:  311:                : FileBase<std::ofstream, T>(std::forward<std::string>(fileName), mode)
       74:  312:            {}
        -:  313:            void open(std::string fileName, openmode mode = std::ios::out)
        -:  314:            {
        -:  315:                return FileBase<std::ofstream, T>::open(std::forward<std::string>(fileName), mode);
        -:  316:            }
        -:  317:    };
        -:  318:    template<typename T>
        -:  319:    class File: public FileBase<std::fstream, T>
        -:  320:    {
        -:  321:        public:
       26:  322:            File(std::string fileName = "", openmode mode = std::ios::in | std::ios::out)
       13:  323:                : FileBase<std::fstream, T>(std::forward<std::string>(fileName), mode)
       26:  324:            {}
        -:  325:            void open(std::string fileName, openmode mode = std::ios::in | std::ios::out)
        -:  326:            {
        -:  327:                return FileBase<std::fstream, T>::open(std::forward<std::string>(fileName), mode);
        -:  328:            }
        -:  329:    };
        -:  330:
        -:  331:        }
        -:  332:    }
        -:  333:}
        -:  334:
        -:  335:#include "file.tpp"
        -:  336:
        -:  337:#endif
